# Released under the MIT License. See LICENSE for details.
#
"""Functionality related to the high level state of the app."""
# pylint: disable=too-many-lines
from __future__ import annotations

import os
import logging
import warnings
from enum import Enum
from typing import TYPE_CHECKING
from concurrent.futures import ThreadPoolExecutor
from functools import cached_property

from efro.call import tpartial

import _babase
from babase._language import LanguageSubsystem
from babase._plugin import PluginSubsystem
from babase._meta import MetadataSubsystem
from babase._net import NetworkSubsystem
from babase._workspace import WorkspaceSubsystem
from babase._appcomponent import AppComponentSubsystem
from babase._appmodeselector import AppModeSelector
from babase._appintent import AppIntentDefault, AppIntentExec

if TYPE_CHECKING:
    import asyncio
    from typing import Any, Callable, Coroutine
    from concurrent.futures import Future

    import babase
    from babase import AppIntent, AppMode, AppSubsystem
    from babase._apputils import AppHealthMonitor

    # __FEATURESET_APP_SUBSYSTEM_IMPORTS_BEGIN__
    # This section generated by batools.appmodule; do not edit.

    from baclassic import ClassicSubsystem
    from baplus import PlusSubsystem
    from bauiv1 import UIV1Subsystem

    # __FEATURESET_APP_SUBSYSTEM_IMPORTS_END__


class App:
    """A class for high level app functionality and state.

    Category: **App Classes**

    Use babase.app to access the single shared instance of this class.

    Note that properties not documented here should be considered internal
    and subject to change without warning.
    """

    # pylint: disable=too-many-public-methods

    plugins: PluginSubsystem
    lang: LanguageSubsystem
    health_monitor: AppHealthMonitor

    # How long we allow shutdown tasks to run before killing them.
    # Currently the entire app hard-exits if shutdown takes 10 seconds,
    # so we need to keep it under that.
    SHUTDOWN_TASK_TIMEOUT_SECONDS = 5

    class State(Enum):
        """High level state the app can be in."""

        # The app has not yet begun starting and should not be used in
        # any way.
        NOT_RUNNING = 0

        # The native layer is spinning up its machinery (screens,
        # renderers, etc.). Nothing should happen in the Python layer
        # until this completes.
        NATIVE_BOOTSTRAPPING = 1

        # Python app subsystems are being inited but should not yet
        # interact or do any work.
        INITING = 2

        # Python app subsystems are inited and interacting, but the app
        # has not yet embarked on a high level course of action. It is
        # doing initial account logins, workspace & asset downloads,
        # etc.
        LOADING = 3

        # All pieces are in place and the app is now doing its thing.
        RUNNING = 4

        # The app is backgrounded or otherwise suspended.
        PAUSED = 5

        # The app is shutting down.
        SHUTTING_DOWN = 6

    class DefaultAppModeSelector(AppModeSelector):
        """Decides which AppModes to use to handle AppIntents.

        This default version is generated by the project updater based
        on the 'default_app_modes' value in the projectconfig.

        It is also possible to modify app mode selection behavior by
        setting app.mode_selector to an instance of a custom
        AppModeSelector subclass. This is a good way to go if you are
        modifying app behavior dynamically via a plugin instead of
        statically in a spinoff project.
        """

        def app_mode_for_intent(
            self, intent: AppIntent
        ) -> type[AppMode] | None:
            # pylint: disable=cyclic-import

            # __DEFAULT_APP_MODE_SELECTION_BEGIN__
            # This section generated by batools.appmodule; do not edit.

            # Ask our default app modes to handle it.
            # (based on 'default_app_modes' in projectconfig).
            import bascenev1
            import babase

            if bascenev1.SceneV1AppMode.can_handle_intent(intent):
                return bascenev1.SceneV1AppMode

            if babase.EmptyAppMode.can_handle_intent(intent):
                return babase.EmptyAppMode

            return None

            # __DEFAULT_APP_MODE_SELECTION_END__

    def __init__(self) -> None:
        """(internal)

        Do not instantiate this class; use babase.app to access
        the single shared instance.
        """

        # Hack for docs-generation.
        if os.environ.get('BA_RUNNING_WITH_DUMMY_MODULES') == '1':
            return

        self.env: babase.Env = _babase.Env()
        self.state = self.State.NOT_RUNNING

        # Default executor which can be used for misc background
        # processing. It should also be passed to any additional asyncio
        # loops we create so that everything shares the same single set
        # of worker threads.
        self.threadpool = ThreadPoolExecutor(thread_name_prefix='baworker')

        self.meta = MetadataSubsystem()
        self.net = NetworkSubsystem()
        self.workspaces = WorkspaceSubsystem()
        self.components = AppComponentSubsystem()

        # This is incremented any time the app is backgrounded or
        # foregrounded; can be a simple way to determine if network data
        # should be refreshed/etc.
        self.fg_state = 0
        self.config_file_healthy: bool = False

        self._subsystems: list[AppSubsystem] = []
        self._native_bootstrapping_completed = False
        self._init_completed = False
        self._meta_scan_completed = False
        self._native_start_called = False
        self._native_paused = False
        self._native_shutdown_called = False
        self._initial_sign_in_completed = False
        self._called_on_initing = False
        self._called_on_loading = False
        self._called_on_running = False
        self._subsystem_registration_ended = False
        self._pending_apply_app_config = False
        self._aioloop: asyncio.AbstractEventLoop | None = None
        self._asyncio_timer: babase.AppTimer | None = None
        self._config: babase.AppConfig | None = None
        self._pending_intent: AppIntent | None = None
        self._intent: AppIntent | None = None
        self._mode: AppMode | None = None
        self._mode_selector: babase.AppModeSelector | None = None
        self._shutdown_task: asyncio.Task[None] | None = None
        self._shutdown_tasks: list[Coroutine[None, None, None]] = [
            self._wait_for_shutdown_suppressions()
        ]

    def postinit(self) -> None:
        """Called after we've been inited and assigned to babase.app."""

        # Hack for docs-generation.
        if os.environ.get('BA_RUNNING_WITH_DUMMY_MODULES') == '1':
            return

        # NOTE: the reason we need a postinit here is that
        # some of this stuff accesses babase.app and that doesn't
        # exist yet as of our __init__() call.

        self.lang = LanguageSubsystem()
        self.plugins = PluginSubsystem()

    @property
    def aioloop(self) -> asyncio.AbstractEventLoop:
        """The logic thread's asyncio event loop.

        This allow async tasks to be run in the logic thread.
        Note that, at this time, the asyncio loop is encapsulated
        and explicitly stepped by the engine's logic thread loop and
        thus things like asyncio.get_running_loop() will not return this
        loop from most places in the logic thread; only from within a
        task explicitly created in this loop.
        """
        assert self._aioloop is not None
        return self._aioloop

    @property
    def config(self) -> babase.AppConfig:
        """The babase.AppConfig instance representing the app's config state."""
        assert self._config is not None
        return self._config

    @property
    def mode_selector(self) -> babase.AppModeSelector:
        """Controls which app-modes are used for handling given intents.

        Plugins can override this to change high level app behavior and
        spinoff projects can change the default implementation for the
        same effect.
        """
        if self._mode_selector is None:
            raise RuntimeError(
                'mode_selector cannot be used until the app reaches'
                ' the running state.'
            )
        return self._mode_selector

    @mode_selector.setter
    def mode_selector(self, selector: babase.AppModeSelector) -> None:
        self._mode_selector = selector

    # __FEATURESET_APP_SUBSYSTEM_PROPERTIES_BEGIN__
    # This section generated by batools.appmodule; do not edit.

    @cached_property
    def classic(self) -> ClassicSubsystem | None:
        """Our classic subsystem (if available)."""
        # pylint: disable=cyclic-import

        try:
            from baclassic import ClassicSubsystem

            return ClassicSubsystem()
        except ImportError:
            return None
        except Exception:
            logging.exception('Error importing baclassic.')
            return None

    @cached_property
    def plus(self) -> PlusSubsystem | None:
        """Our plus subsystem (if available)."""
        # pylint: disable=cyclic-import

        try:
            from baplus import PlusSubsystem

            return PlusSubsystem()
        except ImportError:
            return None
        except Exception:
            logging.exception('Error importing baplus.')
            return None

    @cached_property
    def ui_v1(self) -> UIV1Subsystem:
        """Our ui_v1 subsystem (always available)."""
        # pylint: disable=cyclic-import

        from bauiv1 import UIV1Subsystem

        return UIV1Subsystem()

    # __FEATURESET_APP_SUBSYSTEM_PROPERTIES_END__

    def register_subsystem(self, subsystem: AppSubsystem) -> None:
        """Called by the AppSubsystem class. Do not use directly."""

        # We only allow registering new subsystems if we've not yet
        # reached the 'running' state. This ensures that all subsystems
        # receive a consistent set of callbacks starting with
        # on_app_running().
        if self._subsystem_registration_ended:
            raise RuntimeError(
                'Subsystems can no longer be registered at this point.'
            )
        self._subsystems.append(subsystem)

    def add_shutdown_task(self, coro: Coroutine[None, None, None]) -> None:
        """Add a task to be run on app shutdown.

        Note that tasks will be killed after
        App.SHUTDOWN_TASK_TIMEOUT_SECONDS if they are still running.
        """
        if self.state is self.State.SHUTTING_DOWN:
            raise RuntimeError(
                'Cannot add shutdown tasks with state SHUTTING_DOWN.'
            )
        self._shutdown_tasks.append(coro)

    def run(self) -> None:
        """Run the app to completion.

        Note that this only works on builds where Ballistica manages
        its own event loop.
        """
        _babase.run_app()

    def threadpool_submit_no_wait(self, call: Callable[[], Any]) -> None:
        """Submit a call to the app threadpool where result is not needed.

        Normally, doing work in a thread-pool involves creating a future
        and waiting for its result, which is an important step because it
        propagates any Exceptions raised by the submitted work. When the
        result in not important, however, this call can be used. The app
        will log any exceptions that occur.
        """
        fut = self.threadpool.submit(call)
        fut.add_done_callback(self._threadpool_no_wait_done)

    def set_intent(self, intent: AppIntent) -> None:
        """Set the intent for the app.

        Intent defines what the app is trying to do at a given time.
        This call is asynchronous; the intent switch will happen in the
        logic thread in the near future. If set_intent is called
        repeatedly before the change takes place, the final intent to be
        set will be used.
        """

        # Mark this one as pending. We do this synchronously so that the
        # last one marked actually takes effect if there is overlap
        # (doing this in the bg thread could result in race conditions).
        self._pending_intent = intent

        # Do the actual work of calcing our app-mode/etc. in a bg thread
        # since it may block for a moment to load modules/etc.
        self.threadpool_submit_no_wait(tpartial(self._set_intent, intent))

    def push_apply_app_config(self) -> None:
        """Internal. Use app.config.apply() to apply app config changes."""
        # To be safe, let's run this by itself in the event loop.
        # This avoids potential trouble if this gets called mid-draw or
        # something like that.
        self._pending_apply_app_config = True
        _babase.pushcall(self._apply_app_config, raw=True)

    def on_native_start(self) -> None:
        """Called by the native layer when the app is being started."""
        assert _babase.in_logic_thread()
        assert not self._native_start_called
        self._native_start_called = True
        self._update_state()

    def on_native_bootstrapping_complete(self) -> None:
        """Called by the native layer once its ready to rock."""
        assert _babase.in_logic_thread()
        assert not self._native_bootstrapping_completed
        self._native_bootstrapping_completed = True
        self._update_state()

    def on_native_pause(self) -> None:
        """Called by the native layer when the app pauses."""
        assert _babase.in_logic_thread()
        assert not self._native_paused  # Should avoid redundant calls.
        self._native_paused = True
        self._update_state()

    def on_native_resume(self) -> None:
        """Called by the native layer when the app resumes."""
        assert _babase.in_logic_thread()
        assert self._native_paused  # Should avoid redundant calls.
        self._native_paused = False
        self._update_state()

    def on_native_shutdown(self) -> None:
        """Called by the native layer when the app starts shutting down."""
        assert _babase.in_logic_thread()
        self._native_shutdown_called = True
        self._update_state()

    def read_config(self) -> None:
        """(internal)"""
        from babase._appconfig import read_app_config

        self._config, self.config_file_healthy = read_app_config()

    def handle_deep_link(self, url: str) -> None:
        """Handle a deep link URL."""
        from babase._language import Lstr

        assert _babase.in_logic_thread()

        appname = _babase.appname()
        if url.startswith(f'{appname}://code/'):
            code = url.replace(f'{appname}://code/', '')
            if self.classic is not None:
                self.classic.accounts.add_pending_promo_code(code)
        else:
            try:
                _babase.screenmessage(
                    Lstr(resource='errorText'), color=(1, 0, 0)
                )
                _babase.getsimplesound('error').play()
            except ImportError:
                pass

    def on_initial_sign_in_complete(self) -> None:
        """Called when initial sign-in (or lack thereof) completes.

        This normally gets called by the plus subsystem. The
        initial-sign-in process may include tasks such as syncing
        account workspaces or other data so it may take a substantial
        amount of time.
        """
        assert _babase.in_logic_thread()
        assert not self._initial_sign_in_completed

        # Tell meta it can start scanning extra stuff that just showed
        # up (namely account workspaces).
        self.meta.start_extra_scan()

        self._initial_sign_in_completed = True
        self._update_state()

    def _set_intent(self, intent: AppIntent) -> None:
        # This should be happening in a bg thread.
        assert not _babase.in_logic_thread()
        try:
            # Ask the selector what app-mode to use for this intent.
            if self.mode_selector is None:
                raise RuntimeError('No AppModeSelector set.')
            modetype = self.mode_selector.app_mode_for_intent(intent)

            # NOTE: Since intents are somewhat high level things, should
            # we do some universal thing like a screenmessage saying
            # 'The app cannot handle that request' on failure?

            if modetype is None:
                raise RuntimeError(
                    f'No app-mode found to handle app-intent'
                    f' type {type(intent)}.'
                )

            # Make sure the app-mode the selector gave us *actually*
            # supports the intent.
            if not modetype.can_handle_intent(intent):
                raise RuntimeError(
                    f'Intent {intent} cannot be handled by AppMode type'
                    f' {modetype} (selector {self.mode_selector}'
                    f' incorrectly thinks that it can be).'
                )

            # Ok; seems legit. Now instantiate the mode if necessary and
            # kick back to the logic thread to apply.
            mode = modetype()
            _babase.pushcall(
                tpartial(self._apply_intent, intent, mode),
                from_other_thread=True,
            )
        except Exception:
            logging.exception('Error setting app intent to %s.', intent)
            _babase.pushcall(
                tpartial(self._apply_intent_error, intent),
                from_other_thread=True,
            )

    def _apply_intent(self, intent: AppIntent, mode: AppMode) -> None:
        assert _babase.in_logic_thread()

        # ONLY apply this intent if it is still the most recent one
        # submitted.
        if intent is not self._pending_intent:
            return

        # If the app-mode for this intent is different than the active
        # one, switch.
        if type(mode) is not type(self._mode):
            if self._mode is None:
                is_initial_mode = True
            else:
                is_initial_mode = False
                try:
                    self._mode.on_deactivate()
                except Exception:
                    logging.exception(
                        'Error deactivating app-mode %s.', self._mode
                    )
            self._mode = mode
            try:
                mode.on_activate()
            except Exception:
                # Hmm; what should we do in this case?...
                logging.exception('Error activating app-mode %s.', mode)

            # Let the world know when we first have an app-mode; certain
            # app stuff such as input processing can proceed at that
            # point.
            if is_initial_mode:
                _babase.on_initial_app_mode_set()

        try:
            mode.handle_intent(intent)
        except Exception:
            logging.exception(
                'Error handling intent %s in app-mode %s.', intent, mode
            )

    def _apply_intent_error(self, intent: AppIntent) -> None:
        from babase._language import Lstr

        del intent  # Unused.
        _babase.screenmessage(Lstr(resource='errorText'), color=(1, 0, 0))
        _babase.getsimplesound('error').play()

    def _on_initing(self) -> None:
        """Called when the app enters the initing state.

        Here we can put together subsystems and other pieces for the
        app, but most things should not be doing any work yet.
        """
        # pylint: disable=cyclic-import
        from babase import _asyncio
        from babase import _appconfig
        from babase._apputils import AppHealthMonitor
        from babase import _env

        assert _babase.in_logic_thread()

        _env.on_app_state_initing()

        self._aioloop = _asyncio.setup_asyncio()
        self.health_monitor = AppHealthMonitor()

        # Only proceed if our config file is healthy so we don't
        # overwrite a broken one or whatnot and wipe out data.
        if not self.config_file_healthy:
            if self.classic is not None:
                handled = self.classic.show_config_error_window()
                if handled:
                    return

            # For now on other systems we just overwrite the bum config.
            # At this point settings are already set; lets just commit
            # them to disk.
            _appconfig.commit_app_config(force=True)

        # __FEATURESET_APP_SUBSYSTEM_CREATE_BEGIN__
        # This section generated by batools.appmodule; do not edit.

        # Poke these attrs to create all our subsystems.
        _ = self.plus
        _ = self.classic
        _ = self.ui_v1

        # __FEATURESET_APP_SUBSYSTEM_CREATE_END__

        # We're a pretty short-lived state. This should flip us to
        # 'loading'.
        self._init_completed = True
        self._update_state()

    def _on_loading(self) -> None:
        """Called when we enter the loading state.

        At this point, all built-in pieces of the app should be in place
        and can start talking to each other and doing work. Though at a
        high level, the goal of the app at this point is only to sign in
        to initial accounts, download workspaces, and otherwise prepare
        itself to really 'run'.
        """
        assert _babase.in_logic_thread()

        # Get meta-system scanning built-in stuff in the bg.
        self.meta.start_scan(scan_complete_cb=self._on_meta_scan_complete)

        # Inform all app subsystems in the same order they were inited.
        # Operate on a copy here because subsystems can still be added
        # at this point.
        for subsystem in self._subsystems.copy():
            try:
                subsystem.on_app_loading()
            except Exception:
                logging.exception(
                    'Error in on_app_loading for subsystem %s.', subsystem
                )

        # Normally plus tells us when initial sign-in is done. If plus
        # is not present, however, we just do it ourself so we can
        # proceed on to the running state.
        if self.plus is None:
            _babase.pushcall(self.on_initial_sign_in_complete)

    def _on_meta_scan_complete(self) -> None:
        """Called when meta-scan is done doing its thing."""
        assert _babase.in_logic_thread()

        # Now that we know what's out there, build our final plugin set.
        self.plugins.on_meta_scan_complete()

        assert not self._meta_scan_completed
        self._meta_scan_completed = True
        self._update_state()

    def _on_running(self) -> None:
        """Called when we enter the running state.

        At this point, all workspaces, initial accounts, etc. are in place
        and we can actually get started doing whatever we're gonna do.
        """
        assert _babase.in_logic_thread()

        # Let our native layer know.
        _babase.on_app_running()

        # Set a default app-mode-selector if none has been set yet
        # by a plugin or whatnot.
        if self._mode_selector is None:
            self._mode_selector = self.DefaultAppModeSelector()

        # Inform all app subsystems in the same order they were
        # registered. Operate on a copy here because subsystems can
        # still be added at this point.
        #
        # NOTE: Do we need to allow registering still at this point? If
        # something gets registered here, it won't have its
        # on_app_running callback called. Hmm; I suppose that's the only
        # way that plugins can register subsystems though.
        for subsystem in self._subsystems.copy():
            try:
                subsystem.on_app_running()
            except Exception:
                logging.exception(
                    'Error in on_app_running for subsystem %s.', subsystem
                )

        # Cut off new subsystem additions at this point.
        self._subsystem_registration_ended = True

        # If 'exec' code was provided to the app, always kick that off
        # here as an intent.
        exec_cmd = _babase.exec_arg()
        if exec_cmd is not None:
            self.set_intent(AppIntentExec(exec_cmd))
        elif self._pending_intent is None:
            # Otherwise tell the app to do its default thing *only* if a
            # plugin hasn't already told it to do something.
            self.set_intent(AppIntentDefault())

    def _apply_app_config(self) -> None:
        assert _babase.in_logic_thread()

        _babase.lifecyclelog('apply-app-config')

        # If multiple apply calls have been made, only actually apply
        # once.
        if not self._pending_apply_app_config:
            return

        _pending_apply_app_config = False

        # Inform all app subsystems in the same order they were inited.
        # Operate on a copy here because subsystems may still be able to
        # be added at this point.
        for subsystem in self._subsystems.copy():
            try:
                subsystem.do_apply_app_config()
            except Exception:
                logging.exception(
                    'Error in do_apply_app_config for subsystem %s.', subsystem
                )

        # Let the native layer do its thing.
        _babase.do_apply_app_config()

    def _update_state(self) -> None:
        # pylint: disable=too-many-branches
        assert _babase.in_logic_thread()

        # Shutdown trumps all. Though we can't shut down until init is
        # completed since we need our asyncio stuff to exist for the
        # shutdown process.
        if self._native_shutdown_called and self._init_completed:
            # Entering shutdown state:
            if self.state is not self.State.SHUTTING_DOWN:
                self.state = self.State.SHUTTING_DOWN
                self._on_shutting_down()

        elif self._native_paused:
            # Entering paused state:
            if self.state is not self.State.PAUSED:
                self.state = self.State.PAUSED
                self._on_pause()
        else:
            # Leaving paused state:
            if self.state is self.State.PAUSED:
                self._on_resume()

            # Handle initially entering or returning to other states.
            if self._initial_sign_in_completed and self._meta_scan_completed:
                if self.state != self.State.RUNNING:
                    self.state = self.State.RUNNING
                    _babase.lifecyclelog('app state running')
                    if not self._called_on_running:
                        self._called_on_running = True
                        self._on_running()
            elif self._init_completed:
                if self.state is not self.State.LOADING:
                    self.state = self.State.LOADING
                    _babase.lifecyclelog('app state loading')
                    if not self._called_on_loading:
                        self._called_on_loading = True
                        self._on_loading()
            elif self._native_bootstrapping_completed:
                if self.state is not self.State.INITING:
                    self.state = self.State.INITING
                    _babase.lifecyclelog('app state initing')
                    if not self._called_on_initing:
                        self._called_on_initing = True
                        self._on_initing()
            else:
                # Only possibility left is app-start. We shouldn't be
                # getting called before at least that happens.
                assert self._native_start_called
                assert self.state is self.State.NOT_RUNNING
                if bool(True):
                    self.state = self.State.NATIVE_BOOTSTRAPPING

    async def _shutdown(self) -> None:
        import asyncio

        try:
            async with asyncio.TaskGroup() as task_group:
                for task_coro in self._shutdown_tasks:
                    # Note: Mypy currently complains if we don't take
                    # this return value, but we don't actually need to.
                    # https://github.com/python/mypy/issues/15036
                    _ = task_group.create_task(
                        self._run_shutdown_task(task_coro)
                    )
        except* Exception:
            logging.exception('Unexpected error(s) in shutdown.')

        _babase.complete_shutdown()

    async def _run_shutdown_task(
        self, coro: Coroutine[None, None, None]
    ) -> None:
        """Run a shutdown task; report errors and abort if taking too long."""
        import asyncio

        task = asyncio.create_task(coro)
        try:
            await asyncio.wait_for(task, self.SHUTDOWN_TASK_TIMEOUT_SECONDS)
        except Exception:
            logging.exception('Error in shutdown task.')

    def _on_pause(self) -> None:
        """Called when the app goes to a paused state."""
        assert _babase.in_logic_thread()

        # Pause all app subsystems in the opposite order they were inited.
        for subsystem in reversed(self._subsystems):
            try:
                subsystem.on_app_pause()
            except Exception:
                logging.exception(
                    'Error in on_app_pause for subsystem %s.', subsystem
                )

    def _on_resume(self) -> None:
        """Called when resuming."""
        assert _babase.in_logic_thread()
        self.fg_state += 1

        # Resume all app subsystems in the same order they were inited.
        for subsystem in self._subsystems:
            try:
                subsystem.on_app_resume()
            except Exception:
                logging.exception(
                    'Error in on_app_resume for subsystem %s.', subsystem
                )

    def _on_shutting_down(self) -> None:
        """(internal)"""
        assert _babase.in_logic_thread()

        # Inform app subsystems that we're shutting down in the opposite
        # order they were inited.
        for subsystem in reversed(self._subsystems):
            try:
                subsystem.on_app_shutdown()
            except Exception:
                logging.exception(
                    'Error in on_app_shutdown for subsystem %s.', subsystem
                )

        # Now kick off any async shutdown task(s).
        assert self._aioloop is not None
        self._shutdown_task = self._aioloop.create_task(self._shutdown())

    async def _wait_for_shutdown_suppressions(self) -> None:
        import asyncio

        # Spin and wait for anything blocking shutdown to complete.
        _babase.lifecyclelog('shutdown-suppress wait begin')
        while _babase.shutdown_suppress_count() > 0:
            await asyncio.sleep(0.001)
        _babase.lifecyclelog('shutdown-suppress wait end')

    def _threadpool_no_wait_done(self, fut: Future) -> None:
        try:
            fut.result()
        except Exception:
            logging.exception(
                'Error in work submitted via threadpool_submit_no_wait()'
            )

    # --------------------------------------------------------------------
    # THE FOLLOWING ARE DEPRECATED AND WILL BE REMOVED IN A FUTURE UPDATE.
    # --------------------------------------------------------------------

    @property
    def build_number(self) -> int:
        """Integer build number.

        This value increases by at least 1 with each release of the engine.
        It is independent of the human readable babase.App.version string.
        """
        warnings.warn(
            'app.build_number is deprecated; use app.env.build_number',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.build_number

    @property
    def device_name(self) -> str:
        """Name of the device running the app."""
        warnings.warn(
            'app.device_name is deprecated; use app.env.device_name',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.device_name

    @property
    def config_file_path(self) -> str:
        """Where the app's config file is stored on disk."""
        warnings.warn(
            'app.config_file_path is deprecated;'
            ' use app.env.config_file_path',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.config_file_path

    @property
    def version(self) -> str:
        """Human-readable engine version string; something like '1.3.24'.

        This should not be interpreted as a number; it may contain
        string elements such as 'alpha', 'beta', 'test', etc.
        If a numeric version is needed, use `build_number`.
        """
        warnings.warn(
            'app.version is deprecated; use app.env.version',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.version

    @property
    def debug_build(self) -> bool:
        """Whether the app was compiled in debug mode.

        Debug builds generally run substantially slower than non-debug
        builds due to compiler optimizations being disabled and extra
        checks being run.
        """
        warnings.warn(
            'app.debug_build is deprecated; use app.env.debug',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.debug

    @property
    def test_build(self) -> bool:
        """Whether the app was compiled in test mode.

        Test mode enables extra checks and features that are useful for
        release testing but which do not slow the game down significantly.
        """
        warnings.warn(
            'app.test_build is deprecated; use app.env.test',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.test

    @property
    def data_directory(self) -> str:
        """Path where static app data lives."""
        warnings.warn(
            'app.data_directory is deprecated; use app.env.data_directory',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.data_directory

    @property
    def python_directory_user(self) -> str | None:
        """Path where the app expects its user scripts (mods) to live.

        Be aware that this value may be None if ballistica is running in
        a non-standard environment, and that python-path modifications may
        cause modules to be loaded from other locations.
        """
        warnings.warn(
            'app.python_directory_user is deprecated;'
            ' use app.env.python_directory_user',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.python_directory_user

    @property
    def python_directory_app(self) -> str | None:
        """Path where the app expects its bundled modules to live.

        Be aware that this value may be None if Ballistica is running in
        a non-standard environment, and that python-path modifications may
        cause modules to be loaded from other locations.
        """
        warnings.warn(
            'app.python_directory_app is deprecated;'
            ' use app.env.python_directory_app',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.python_directory_app

    @property
    def python_directory_app_site(self) -> str | None:
        """Path where the app expects its bundled pip modules to live.

        Be aware that this value may be None if Ballistica is running in
        a non-standard environment, and that python-path modifications may
        cause modules to be loaded from other locations.
        """
        warnings.warn(
            'app.python_directory_app_site is deprecated;'
            ' use app.env.python_directory_app_site',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.python_directory_app_site

    @property
    def api_version(self) -> int:
        """The app's api version.

        Only Python modules and packages associated with the current API
        version number will be detected by the game (see the ba_meta tag).
        This value will change whenever substantial backward-incompatible
        changes are introduced to ballistica APIs. When that happens,
        modules/packages should be updated accordingly and set to target
        the newer API version number.
        """
        warnings.warn(
            'app.api_version is deprecated; use app.env.api_version',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.api_version

    @property
    def on_tv(self) -> bool:
        """Whether the app is currently running on a TV."""
        warnings.warn(
            'app.on_tv is deprecated; use app.env.tv',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.tv

    @property
    def vr_mode(self) -> bool:
        """Whether the app is currently running in VR."""
        warnings.warn(
            'app.vr_mode is deprecated; use app.env.vr',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.vr

    # __SPINOFF_REQUIRE_UI_V1_BEGIN__

    @property
    def toolbar_test(self) -> bool:
        """(internal)."""
        warnings.warn(
            'app.toolbar_test is deprecated; use app.ui_v1.use_toolbars',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.ui_v1.use_toolbars

    # __SPINOFF_REQUIRE_UI_V1_END__

    @property
    def arcade_mode(self) -> bool:
        """Whether the app is currently running on arcade hardware."""
        warnings.warn(
            'app.arcade_mode is deprecated; use app.env.arcade',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.arcade

    @property
    def headless_mode(self) -> bool:
        """Whether the app is running headlessly."""
        warnings.warn(
            'app.headless_mode is deprecated; use app.env.headless',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.headless

    @property
    def demo_mode(self) -> bool:
        """Whether the app is targeting a demo experience."""
        warnings.warn(
            'app.demo_mode is deprecated; use app.env.demo',
            DeprecationWarning,
            stacklevel=2,
        )
        return self.env.demo

    # __SPINOFF_REQUIRE_SCENE_V1_BEGIN__

    @property
    def protocol_version(self) -> int:
        """(internal)."""
        import bascenev1

        warnings.warn(
            'app.protocol_version is deprecated;'
            ' use bascenev1.protocol_version()',
            DeprecationWarning,
            stacklevel=2,
        )
        return bascenev1.protocol_version()

    # __SPINOFF_REQUIRE_SCENE_V1_END__
