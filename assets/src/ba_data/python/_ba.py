# Released under the MIT License. See LICENSE for details.
#
"""A dummy stub module for the real _ba.

The real _ba is a compiled extension module and only available
in the live engine. This dummy-module allows Pylint/Mypy/etc. to
function reasonably well outside of that environment.

Make sure this file is never included in dirs seen by the engine!

In the future perhaps this can be a stub (.pyi) file, but we will need
to make sure that it works with all our tools (mypy, pylint, pycharm).

NOTE: This file was autogenerated by batools.dummymodule; do not edit by hand.
"""

# I'm sorry Pylint. I know this file saddens you. Be strong.
# pylint: disable=useless-suppression
# pylint: disable=unnecessary-pass
# pylint: disable=use-dict-literal
# pylint: disable=use-list-literal
# pylint: disable=unused-argument
# pylint: disable=missing-docstring
# pylint: disable=too-many-locals
# pylint: disable=redefined-builtin
# pylint: disable=too-many-lines
# pylint: disable=redefined-outer-name
# pylint: disable=invalid-name
# pylint: disable=no-value-for-parameter

from __future__ import annotations

from typing import TYPE_CHECKING, overload, Sequence, TypeVar

from ba._generated.enums import TimeFormat, TimeType

if TYPE_CHECKING:
    from typing import Any, Callable, Literal
    from ba._app import App
    import ba


_T = TypeVar('_T')

app: App


def _uninferrable() -> Any:
    """Get an "Any" in mypy and "uninferrable" in Pylint."""
    # pylint: disable=undefined-variable
    return _not_a_real_variable  # type: ignore


class ActivityData:

    """(internal)"""

    def exists(self) -> bool:

        """Returns whether the ActivityData still exists.
        Most functionality will fail on a nonexistent instance.
        """
        return bool()

    def expire(self) -> None:

        """Expires the internal data for the activity"""
        return None

    def make_foreground(self) -> None:

        """Sets this activity as the foreground one in its session."""
        return None

    def start(self) -> None:

        """Begins the activity running"""
        return None


class CollideModel:

    """A reference to a collide-model.

    Category: **Asset Classes**

    Use ba.getcollidemodel() to instantiate one.
    """

    pass


class Context:

    """A game context state.

    Category: **General Utility Classes**

    Many operations such as ba.newnode() or ba.gettexture() operate
    implicitly on the current context. Each ba.Activity has its own
    Context and objects within that activity (nodes, media, etc) can only
    interact with other objects from that context.

    In general, as a modder, you should not need to worry about contexts,
    since timers and other callbacks will take care of saving and
    restoring the context automatically, but there may be rare cases where
    you need to deal with them, such as when loading media in for use in
    the UI (there is a special `'ui'` context for all
    user-interface-related functionality).

    When instantiating a ba.Context instance, a single `'source'` argument
    is passed, which can be one of the following strings/objects:

    ###### `'empty'`
    > Gives an empty context; it can be handy to run code here to ensure
    it does no loading of media, creation of nodes, etc.

    ###### `'current'`
    > Sets the context object to the current context.

    ###### `'ui'`
    > Sets to the UI context. UI functions as well as loading of media to
    be used in said functions must happen in the UI context.

    ###### A ba.Activity instance
    > Gives the context for the provided ba.Activity.
      Most all code run during a game happens in an Activity's Context.

    ###### A ba.Session instance
    > Gives the context for the provided ba.Session.
    Generally a user should not need to run anything here.


    ##### Usage
    Contexts are generally used with the python 'with' statement, which
    sets the context as current on entry and resets it to the previous
    value on exit.

    ##### Example
    Load a few textures into the UI context
    (for use in widgets, etc):
    >>> with ba.Context('ui'):
    ...     tex1 = ba.gettexture('foo_tex_1')
    ...     tex2 = ba.gettexture('foo_tex_2')
    """

    def __init__(self, source: Any):
        pass

    def __enter__(self) -> None:
        """Support for "with" statement."""
        pass

    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
        """Support for "with" statement."""
        pass


class ContextCall:

    """A context-preserving callable.

    Category: **General Utility Classes**

    A ContextCall wraps a callable object along with a reference
    to the current context (see ba.Context); it handles restoring the
    context when run and automatically clears itself if the context
    it belongs to shuts down.

    Generally you should not need to use this directly; all standard
    Ballistica callbacks involved with timers, materials, UI functions,
    etc. handle this under-the-hood you don't have to worry about it.
    The only time it may be necessary is if you are implementing your
    own callbacks, such as a worker thread that does some action and then
    runs some game code when done. By wrapping said callback in one of
    these, you can ensure that you will not inadvertently be keeping the
    current activity alive or running code in a torn-down (expired)
    context.

    You can also use ba.WeakCall for similar functionality, but
    ContextCall has the added bonus that it will not run during context
    shutdown, whereas ba.WeakCall simply looks at whether the target
    object still exists.

    ##### Examples
    **Example A:** code like this can inadvertently prevent our activity
    (self) from ending until the operation completes, since the bound
    method we're passing (self.dosomething) contains a strong-reference
    to self).
    >>> start_some_long_action(callback_when_done=self.dosomething)

    **Example B:** in this case our activity (self) can still die
    properly; the callback will clear itself when the activity starts
    shutting down, becoming a harmless no-op and releasing the reference
    to our activity.

    >>> start_long_action(
    ...     callback_when_done=ba.ContextCall(self.mycallback))
    """

    def __init__(self, call: Callable):
        pass


class Data:

    """A reference to a data object.

    Category: **Asset Classes**

    Use ba.getdata() to instantiate one.
    """

    def getvalue(self) -> Any:

        """Return the data object's value.

        This can consist of anything representable by json (dicts, lists,
        numbers, bools, None, etc).
        Note that this call will block if the data has not yet been loaded,
        so it can be beneficial to plan a short bit of time between when
        the data object is requested and when it's value is accessed.
        """
        return _uninferrable()


class InputDevice:

    """An input-device such as a gamepad, touchscreen, or keyboard.

    Category: **Gameplay Classes**
    """

    allows_configuring: bool

    """Whether the input-device can be configured."""

    has_meaningful_button_names: bool

    """Whether button names returned by this instance match labels
       on the actual device. (Can be used to determine whether to show
       them in controls-overlays, etc.)."""

    player: ba.SessionPlayer | None

    """The player associated with this input device."""

    client_id: int

    """The numeric client-id this device is associated with.
       This is only meaningful for remote client inputs; for
       all local devices this will be -1."""

    name: str

    """The name of the device."""

    unique_identifier: str

    """A string that can be used to persistently identify the device,
       even among other devices of the same type. Used for saving
       prefs, etc."""

    id: int

    """The unique numeric id of this device."""

    instance_number: int

    """The number of this device among devices of the same type."""

    is_controller_app: bool

    """Whether this input-device represents a locally-connected
       controller-app."""

    is_remote_client: bool

    """Whether this input-device represents a remotely-connected
       client."""

    def exists(self) -> bool:

        """Return whether the underlying device for this object is
        still present.
        """
        return bool()

    def get_axis_name(self, axis_id: int) -> str:

        """Given an axis ID, return the name of the axis on this device.

        Can return an empty string if the value is not meaningful to humans.
        """
        return str()

    def get_button_name(self, button_id: int) -> ba.Lstr:

        """Given a button ID, return a human-readable name for that key/button.

        Can return an empty string if the value is not meaningful to humans.
        """
        import ba  # pylint: disable=cyclic-import

        return ba.Lstr(value='')

    def get_default_player_name(self) -> str:

        """(internal)

        Returns the default player name for this device. (used for the 'random'
        profile)
        """
        return str()

    def get_player_profiles(self) -> dict:

        """(internal)"""
        return dict()

    def get_v1_account_name(self, full: bool) -> str:

        """Returns the account name associated with this device.

        (can be used to get account names for remote players)
        """
        return str()

    def is_connected_to_remote_player(self) -> bool:

        """(internal)"""
        return bool()

    def remove_remote_player_from_game(self) -> None:

        """(internal)"""
        return None


class Material:

    """An entity applied to game objects to modify collision behavior.

    Category: **Gameplay Classes**

    A material can affect physical characteristics, generate sounds,
    or trigger callback functions when collisions occur.

    Materials are applied to 'parts', which are groups of one or more
    rigid bodies created as part of a ba.Node. Nodes can have any number
    of parts, each with its own set of materials. Generally materials are
    specified as array attributes on the Node. The `spaz` node, for
    example, has various attributes such as `materials`,
    `roller_materials`, and `punch_materials`, which correspond
    to the various parts it creates.

    Use ba.Material to instantiate a blank material, and then use its
    ba.Material.add_actions() method to define what the material does.
    """

    def __init__(self, label: str | None = None):
        pass

    label: str

    """A label for the material; only used for debugging."""

    def add_actions(
        self, actions: tuple, conditions: tuple | None = None
    ) -> None:

        """Add one or more actions to the material, optionally with conditions.

        ##### Conditions
        Conditions are provided as tuples which can be combined
        to form boolean logic. A single condition might look like
        `('condition_name', cond_arg)`, or a more complex nested one
        might look like `(('some_condition', cond_arg), 'or',
        ('another_condition', cond2_arg))`.

        `'and'`, `'or'`, and `'xor'` are available to chain
        together 2 conditions, as seen above.

        ##### Available Conditions
        ###### `('they_have_material', material)`
        > Does the part we're hitting have a given ba.Material?

        ###### `('they_dont_have_material', material)`
        > Does the part we're hitting not have a given ba.Material?

        ###### `('eval_colliding')`
        > Is `'collide'` true at this point
        in material evaluation? (see the `modify_part_collision` action)

        ###### `('eval_not_colliding')`
        > Is 'collide' false at this point
        in material evaluation? (see the `modify_part_collision` action)

        ###### `('we_are_younger_than', age)`
        > Is our part younger than `age` (in milliseconds)?

        ###### `('we_are_older_than', age)`
        > Is our part older than `age` (in milliseconds)?

        ###### `('they_are_younger_than', age)`
        > Is the part we're hitting younger than `age` (in milliseconds)?

        ###### `('they_are_older_than', age)`
        > Is the part we're hitting older than `age` (in milliseconds)?

        ###### `('they_are_same_node_as_us')`
        > Does the part we're hitting belong to the same ba.Node as us?

        ###### `('they_are_different_node_than_us')`
        > Does the part we're hitting belong to a different ba.Node than us?

        ##### Actions
        In a similar manner, actions are specified as tuples.
        Multiple actions can be specified by providing a tuple
        of tuples.

        ##### Available Actions
        ###### `('call', when, callable)`
        > Calls the provided callable;
        `when` can be either `'at_connect'` or `'at_disconnect'`.
        `'at_connect'` means to fire
        when the two parts first come in contact; `'at_disconnect'`
        means to fire once they cease being in contact.

        ###### `('message', who, when, message_obj)`
        > Sends a message object;
        `who` can be either `'our_node'` or `'their_node'`, `when` can be
        `'at_connect'` or `'at_disconnect'`, and `message_obj` is the message
        object to send.
        This has the same effect as calling the node's
        ba.Node.handlemessage() method.

        ###### `('modify_part_collision', attr, value)`
        > Changes some
        characteristic of the physical collision that will occur between
        our part and their part. This change will remain in effect as
        long as the two parts remain overlapping. This means if you have a
        part with a material that turns `'collide'` off against parts
        younger than 100ms, and it touches another part that is 50ms old,
        it will continue to not collide with that part until they separate,
        even if the 100ms threshold is passed. Options for attr/value are:
        `'physical'` (boolean value; whether a *physical* response will
        occur at all), `'friction'` (float value; how friction-y the
        physical response will be), `'collide'` (boolean value;
        whether *any* collision will occur at all, including non-physical
        stuff like callbacks), `'use_node_collide'`
        (boolean value; whether to honor modify_node_collision
        overrides for this collision), `'stiffness'` (float value,
        how springy the physical response is), `'damping'` (float
        value, how damped the physical response is), `'bounce'` (float
        value; how bouncy the physical response is).

        ###### `('modify_node_collision', attr, value)`
        > Similar to
        `modify_part_collision`, but operates at a node-level.
        collision attributes set here will remain in effect as long as
        *anything* from our part's node and their part's node overlap.
        A key use of this functionality is to prevent new nodes from
        colliding with each other if they appear overlapped;
        if `modify_part_collision` is used, only the individual
        parts that were overlapping would avoid contact, but other parts
        could still contact leaving the two nodes 'tangled up'. Using
        `modify_node_collision` ensures that the nodes must completely
        separate before they can start colliding. Currently the only attr
        available here is `'collide'` (a boolean value).

        ###### `('sound', sound, volume)`
        > Plays a ba.Sound when a collision
        occurs, at a given volume, regardless of the collision speed/etc.

        ###### `('impact_sound', sound, targetImpulse, volume)`
        > Plays a sound
        when a collision occurs, based on the speed of impact.
        Provide a ba.Sound, a target-impulse, and a volume.

        ###### `('skid_sound', sound, targetImpulse, volume)`
        > Plays a sound
        during a collision when parts are 'scraping' against each other.
        Provide a ba.Sound, a target-impulse, and a volume.

        ###### `('roll_sound', sound, targetImpulse, volume)`
        > Plays a sound
        during a collision when parts are 'rolling' against each other.
        Provide a ba.Sound, a target-impulse, and a volume.

        ##### Examples
        **Example 1:** create a material that lets us ignore
        collisions against any nodes we touch in the first
        100 ms of our existence; handy for preventing us from
        exploding outward if we spawn on top of another object:
        >>> m = ba.Material()
        ... m.add_actions(
        ...     conditions=(('we_are_younger_than', 100),
        ...                 'or', ('they_are_younger_than', 100)),
        ...     actions=('modify_node_collision', 'collide', False))

        **Example 2:** send a ba.DieMessage to anything we touch, but cause
        no physical response. This should cause any ba.Actor to drop dead:
        >>> m = ba.Material()
        ... m.add_actions(
        ...     actions=(('modify_part_collision', 'physical', False),
        ...              ('message', 'their_node', 'at_connect',
        ...                  ba.DieMessage())))

        **Example 3:** play some sounds when we're contacting the ground:
        >>> m = ba.Material()
        ... m.add_actions(
        ...     conditions=('they_have_material',
        ...                 shared.footing_material),
        ...     actions=(('impact_sound', ba.getsound('metalHit'), 2, 5),
        ...              ('skid_sound', ba.getsound('metalSkid'), 2, 5)))
        """
        return None


class Model:

    """A reference to a model.

    Category: **Asset Classes**

    Models are used for drawing.
    Use ba.getmodel() to instantiate one.
    """

    pass


class Node:

    """Reference to a Node; the low level building block of the game.

    Category: **Gameplay Classes**

    At its core, a game is nothing more than a scene of Nodes
    with attributes getting interconnected or set over time.

    A ba.Node instance should be thought of as a weak-reference
    to a game node; *not* the node itself. This means a Node's
    lifecycle is completely independent of how many Python references
    to it exist. To explicitly add a new node to the game, use
    ba.newnode(), and to explicitly delete one, use ba.Node.delete().
    ba.Node.exists() can be used to determine if a Node still points to
    a live node in the game.

    You can use `ba.Node(None)` to instantiate an invalid
    Node reference (sometimes used as attr values/etc).
    """

    # Note attributes:
    # NOTE: I'm just adding *all* possible node attrs here
    # now now since we have a single ba.Node type; in the
    # future I hope to create proper individual classes
    # corresponding to different node types with correct
    # attributes per node-type.
    color: Sequence[float] = (0.0, 0.0, 0.0)
    size: Sequence[float] = (0.0, 0.0, 0.0)
    position: Sequence[float] = (0.0, 0.0, 0.0)
    position_center: Sequence[float] = (0.0, 0.0, 0.0)
    position_forward: Sequence[float] = (0.0, 0.0, 0.0)
    punch_position: Sequence[float] = (0.0, 0.0, 0.0)
    punch_velocity: Sequence[float] = (0.0, 0.0, 0.0)
    velocity: Sequence[float] = (0.0, 0.0, 0.0)
    name_color: Sequence[float] = (0.0, 0.0, 0.0)
    tint_color: Sequence[float] = (0.0, 0.0, 0.0)
    tint2_color: Sequence[float] = (0.0, 0.0, 0.0)
    text: ba.Lstr | str = ''
    texture: ba.Texture | None = None
    tint_texture: ba.Texture | None = None
    times: Sequence[int] = (1, 2, 3, 4, 5)
    values: Sequence[float] = (1.0, 2.0, 3.0, 4.0)
    offset: float = 0.0
    input0: float = 0.0
    input1: float = 0.0
    input2: float = 0.0
    input3: float = 0.0
    flashing: bool = False
    scale: float | Sequence[float] = 0.0
    opacity: float = 0.0
    loop: bool = False
    time1: int = 0
    time2: int = 0
    timemax: int = 0
    client_only: bool = False
    materials: Sequence[Material] = ()
    roller_materials: Sequence[Material] = ()
    name: str = ''
    punch_materials: Sequence[ba.Material] = ()
    pickup_materials: Sequence[ba.Material] = ()
    extras_material: Sequence[ba.Material] = ()
    rotate: float = 0.0
    hold_node: ba.Node | None = None
    hold_body: int = 0
    host_only: bool = False
    premultiplied: bool = False
    source_player: ba.Player | None = None
    model_opaque: ba.Model | None = None
    model_transparent: ba.Model | None = None
    damage_smoothed: float = 0.0
    gravity_scale: float = 1.0
    punch_power: float = 0.0
    punch_momentum_linear: Sequence[float] = (0.0, 0.0, 0.0)
    punch_momentum_angular: float = 0.0
    rate: int = 0
    vr_depth: float = 0.0
    is_area_of_interest: bool = False
    jump_pressed: bool = False
    pickup_pressed: bool = False
    punch_pressed: bool = False
    bomb_pressed: bool = False
    fly_pressed: bool = False
    hold_position_pressed: bool = False
    knockout: float = 0.0
    invincible: bool = False
    stick_to_owner: bool = False
    damage: int = 0
    run: float = 0.0
    move_up_down: float = 0.0
    move_left_right: float = 0.0
    curse_death_time: int = 0
    boxing_gloves: bool = False
    hockey: bool = False
    use_fixed_vr_overlay: bool = False
    allow_kick_idle_players: bool = False
    music_continuous: bool = False
    music_count: int = 0
    hurt: float = 0.0
    always_show_health_bar: bool = False
    mini_billboard_1_texture: ba.Texture | None = None
    mini_billboard_1_start_time: int = 0
    mini_billboard_1_end_time: int = 0
    mini_billboard_2_texture: ba.Texture | None = None
    mini_billboard_2_start_time: int = 0
    mini_billboard_2_end_time: int = 0
    mini_billboard_3_texture: ba.Texture | None = None
    mini_billboard_3_start_time: int = 0
    mini_billboard_3_end_time: int = 0
    boxing_gloves_flashing: bool = False
    dead: bool = False
    floor_reflection: bool = False
    debris_friction: float = 0.0
    debris_kill_height: float = 0.0
    vr_near_clip: float = 0.0
    shadow_ortho: bool = False
    happy_thoughts_mode: bool = False
    shadow_offset: Sequence[float] = (0.0, 0.0)
    paused: bool = False
    time: int = 0
    ambient_color: Sequence[float] = (1.0, 1.0, 1.0)
    camera_mode: str = 'rotate'
    frozen: bool = False
    area_of_interest_bounds: Sequence[float] = (-1, -1, -1, 1, 1, 1)
    shadow_range: Sequence[float] = (0, 0, 0, 0)
    counter_text: str = ''
    counter_texture: ba.Texture | None = None
    shattered: int = 0
    billboard_texture: ba.Texture | None = None
    billboard_cross_out: bool = False
    billboard_opacity: float = 0.0
    slow_motion: bool = False
    music: str = ''
    vr_camera_offset: Sequence[float] = (0.0, 0.0, 0.0)
    vr_overlay_center: Sequence[float] = (0.0, 0.0, 0.0)
    vr_overlay_center_enabled: bool = False
    vignette_outer: Sequence[float] = (0.0, 0.0)
    vignette_inner: Sequence[float] = (0.0, 0.0)
    tint: Sequence[float] = (1.0, 1.0, 1.0)

    def add_death_action(self, action: Callable[[], None]) -> None:

        """Add a callable object to be called upon this node's death.
        Note that these actions are run just after the node dies, not before.
        """
        return None

    def connectattr(self, srcattr: str, dstnode: Node, dstattr: str) -> None:

        """Connect one of this node's attributes to an attribute on another
        node. This will immediately set the target attribute's value to that
        of the source attribute, and will continue to do so once per step
        as long as the two nodes exist. The connection can be severed by
        setting the target attribute to any value or connecting another
        node attribute to it.

        ##### Example
        Create a locator and attach a light to it:
        >>> light = ba.newnode('light')
        ... loc = ba.newnode('locator', attrs={'position': (0, 10, 0)})
        ... loc.connectattr('position', light, 'position')
        """
        return None

    def delete(self, ignore_missing: bool = True) -> None:

        """Delete the node. Ignores already-deleted nodes if `ignore_missing`
        is True; otherwise a ba.NodeNotFoundError is thrown.
        """
        return None

    def exists(self) -> bool:

        """Returns whether the Node still exists.
        Most functionality will fail on a nonexistent Node, so it's never a bad
        idea to check this.

        Note that you can also use the boolean operator for this same
        functionality, so a statement such as "if mynode" will do
        the right thing both for Node objects and values of None.
        """
        return bool()

    # Show that ur return type varies based on "doraise" value:
    @overload
    def getdelegate(
        self, type: type[_T], doraise: Literal[False] = False
    ) -> _T | None:
        ...

    @overload
    def getdelegate(self, type: type[_T], doraise: Literal[True]) -> _T:
        ...

    def getdelegate(self, type: Any, doraise: bool = False) -> Any:

        """Return the node's current delegate object if it matches
        a certain type.

        If the node has no delegate or it is not an instance of the passed
        type, then None will be returned. If 'doraise' is True, then an
        ba.DelegateNotFoundError will be raised instead.
        """
        return None

    def getname(self) -> str:

        """Return the name assigned to a Node; used mainly for debugging"""
        return str()

    def getnodetype(self) -> str:

        """Return the type of Node referenced by this object as a string.
        (Note this is different from the Python type which is always ba.Node)
        """
        return str()

    def handlemessage(self, *args: Any) -> None:

        """General message handling; can be passed any message object.

        All standard message objects are forwarded along to the ba.Node's
        delegate for handling (generally the ba.Actor that made the node).

        ba.Node-s are unique, however, in that they can be passed a second
        form of message; 'node-messages'.  These consist of a string type-name
        as a first argument along with the args specific to that type name
        as additional arguments.
        Node-messages communicate directly with the low-level node layer
        and are delivered simultaneously on all game clients,
        acting as an alternative to setting node attributes.
        """
        return None


class SessionData:

    """(internal)"""

    def exists(self) -> bool:

        """Returns whether the SessionData still exists.
        Most functionality will fail on a nonexistent instance.
        """
        return bool()


class SessionPlayer:

    """A reference to a player in the ba.Session.

    Category: **Gameplay Classes**

    These are created and managed internally and
    provided to your ba.Session/ba.Activity instances.
    Be aware that, like `ba.Node`s, ba.SessionPlayer objects are 'weak'
    references under-the-hood; a player can leave the game at
     any point. For this reason, you should make judicious use of the
    ba.SessionPlayer.exists() method (or boolean operator) to ensure
    that a SessionPlayer is still present if retaining references to one
    for any length of time.
    """

    id: int

    """The unique numeric ID of the Player.

       Note that you can also use the boolean operator for this same
       functionality, so a statement such as "if player" will do
       the right thing both for Player objects and values of None."""

    in_game: bool

    """This bool value will be True once the Player has completed
       any lobby character/team selection."""

    sessionteam: ba.SessionTeam

    """The ba.SessionTeam this Player is on. If the SessionPlayer
       is still in its lobby selecting a team/etc. then a
       ba.SessionTeamNotFoundError will be raised."""

    inputdevice: ba.InputDevice

    """The input device associated with the player."""

    color: Sequence[float]

    """The base color for this Player.
       In team games this will match the ba.SessionTeam's color."""

    highlight: Sequence[float]

    """A secondary color for this player.
       This is used for minor highlights and accents
       to allow a player to stand apart from his teammates
       who may all share the same team (primary) color."""

    character: str

    """The character this player has selected in their profile."""

    activityplayer: ba.Player | None

    """The current game-specific instance for this player."""

    def assigninput(
        self, type: ba.InputType | tuple[ba.InputType, ...], call: Callable
    ) -> None:

        """Set the python callable to be run for one or more types of input."""
        return None

    def exists(self) -> bool:

        """Return whether the underlying player is still in the game."""
        return bool()

    def get_icon(self) -> dict[str, Any]:

        """Returns the character's icon (images, colors, etc contained
        in a dict.
        """
        return {'foo': 'bar'}

    def get_icon_info(self) -> dict[str, Any]:

        """(internal)"""
        return {'foo': 'bar'}

    def get_v1_account_id(self) -> str:

        """Return the V1 Account ID this player is signed in under, if
        there is one and it can be determined with relative certainty.
        Returns None otherwise. Note that this may require an active
        internet connection (especially for network-connected players)
        and may return None for a short while after a player initially
        joins (while verification occurs).
        """
        return str()

    def getname(self, full: bool = False, icon: bool = True) -> str:

        """Returns the player's name. If icon is True, the long version of the
        name may include an icon.
        """
        return str()

    def remove_from_game(self) -> None:

        """Removes the player from the game."""
        return None

    def resetinput(self) -> None:

        """Clears out the player's assigned input actions."""
        return None

    def set_icon_info(
        self,
        texture: str,
        tint_texture: str,
        tint_color: Sequence[float],
        tint2_color: Sequence[float],
    ) -> None:

        """(internal)"""
        return None

    def setactivity(self, activity: ba.Activity | None) -> None:

        """(internal)"""
        return None

    def setdata(
        self,
        team: ba.SessionTeam,
        character: str,
        color: Sequence[float],
        highlight: Sequence[float],
    ) -> None:

        """(internal)"""
        return None

    def setname(
        self, name: str, full_name: str | None = None, real: bool = True
    ) -> None:

        """Set the player's name to the provided string.
        A number will automatically be appended if the name is not unique from
        other players.
        """
        return None

    def setnode(self, node: Node | None) -> None:

        """(internal)"""
        return None


class Sound:

    """A reference to a sound.

    Category: **Asset Classes**

    Use ba.getsound() to instantiate one.
    """

    pass


class Texture:

    """A reference to a texture.

    Category: **Asset Classes**

    Use ba.gettexture() to instantiate one.
    """

    pass


class Timer:

    """Timers are used to run code at later points in time.

    Category: **General Utility Classes**

    This class encapsulates a timer in the current ba.Context.
    The underlying timer will be destroyed when either this object is
    no longer referenced or when its Context (Activity, etc.) dies. If you
    do not want to worry about keeping a reference to your timer around,
    you should use the ba.timer() function instead.

    ###### time
    > Length of time (in seconds by default) that the timer will wait
    before firing. Note that the actual delay experienced may vary
    depending on the timetype. (see below)

    ###### call
    > A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as ba.WeakCall if that is not
    desired.

    ###### repeat
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ###### timetype
    > A ba.TimeType value determining which timeline the timer is
    placed onto.

    ###### timeformat
    > A ba.TimeFormat value determining how the passed time is
    interpreted.

    ##### Example

    Use a Timer object to print repeatedly for a few seconds:
    >>> def say_it():
    ...     ba.screenmessage('BADGER!')
    ... def stop_saying_it():
    ...     self.t = None
    ... ba.screenmessage('MUSHROOM MUSHROOM!')
    ... # Create our timer; it will run as long as we have the self.t ref.
    ... self.t = ba.Timer(0.3, say_it, repeat=True)
    ... # Now fire off a one-shot timer to kill it.
    ... ba.timer(3.89, stop_saying_it)
    """

    def __init__(
        self,
        time: float,
        call: Callable[[], Any],
        repeat: bool = False,
        timetype: ba.TimeType = TimeType.SIM,
        timeformat: ba.TimeFormat = TimeFormat.SECONDS,
        suppress_format_warning: bool = False,
    ):
        pass


class Vec3(Sequence[float]):

    """A vector of 3 floats.

    Category: **General Utility Classes**

    These can be created the following ways (checked in this order):
    - with no args, all values are set to 0
    - with a single numeric arg, all values are set to that value
    - with a single three-member sequence arg, sequence values are copied
    - otherwise assumes individual x/y/z args (positional or keywords)
    """

    x: float

    """The vector's X component."""

    y: float

    """The vector's Y component."""

    z: float

    """The vector's Z component."""

    # pylint: disable=function-redefined

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, value: float):
        pass

    @overload
    def __init__(self, values: Sequence[float]):
        pass

    @overload
    def __init__(self, x: float, y: float, z: float):
        pass

    def __init__(self, *args: Any, **kwds: Any):
        pass

    def __add__(self, other: Vec3) -> Vec3:
        return self

    def __sub__(self, other: Vec3) -> Vec3:
        return self

    @overload
    def __mul__(self, other: float) -> Vec3:
        return self

    @overload
    def __mul__(self, other: Sequence[float]) -> Vec3:
        return self

    def __mul__(self, other: Any) -> Any:
        return self

    @overload
    def __rmul__(self, other: float) -> Vec3:
        return self

    @overload
    def __rmul__(self, other: Sequence[float]) -> Vec3:
        return self

    def __rmul__(self, other: Any) -> Any:
        return self

    # (for index access)
    def __getitem__(self, typeargs: Any) -> Any:
        return 0.0

    def __len__(self) -> int:
        return 3

    # (for iterator access)
    def __iter__(self) -> Any:
        return self

    def __next__(self) -> float:
        return 0.0

    def __neg__(self) -> Vec3:
        return self

    def __setitem__(self, index: int, val: float) -> None:
        pass

    def cross(self, other: Vec3) -> Vec3:

        """Returns the cross product of this vector and another."""
        return Vec3()

    def dot(self, other: Vec3) -> float:

        """Returns the dot product of this vector and another."""
        return float()

    def length(self) -> float:

        """Returns the length of the vector."""
        return float()

    def normalized(self) -> Vec3:

        """Returns a normalized version of the vector."""
        return Vec3()


class Widget:

    """Internal type for low level UI elements; buttons, windows, etc.

    Category: **User Interface Classes**

    This class represents a weak reference to a widget object
    in the internal C++ layer. Currently, functions such as
    ba.buttonwidget() must be used to instantiate or edit these.
    """

    def activate(self) -> None:

        """Activates a widget; the same as if it had been clicked."""
        return None

    def add_delete_callback(self, call: Callable) -> None:

        """Add a call to be run immediately after this widget is destroyed."""
        return None

    def delete(self, ignore_missing: bool = True) -> None:

        """Delete the Widget. Ignores already-deleted Widgets if ignore_missing
        is True; otherwise an Exception is thrown.
        """
        return None

    def exists(self) -> bool:

        """Returns whether the Widget still exists.
        Most functionality will fail on a nonexistent widget.

        Note that you can also use the boolean operator for this same
        functionality, so a statement such as "if mywidget" will do
        the right thing both for Widget objects and values of None.
        """
        return bool()

    def get_children(self) -> list[ba.Widget]:

        """Returns any child Widgets of this Widget."""
        return [Widget()]

    def get_screen_space_center(self) -> tuple[float, float]:

        """Returns the coords of the ba.Widget center relative to the center
        of the screen. This can be useful for placing pop-up windows and other
        special cases.
        """
        return (0.0, 0.0)

    def get_selected_child(self) -> ba.Widget | None:

        """Returns the selected child Widget or None if nothing is selected."""
        return Widget()

    def get_widget_type(self) -> str:

        """Return the internal type of the Widget as a string. Note that this
        is different from the Python ba.Widget type, which is the same for
        all widgets.
        """
        return str()


def _app() -> ba.App:

    """(internal)"""
    import ba  # pylint: disable=cyclic-import

    return ba.App()


def add_clean_frame_callback(call: Callable) -> None:

    """(internal)

    Provide an object to be called once the next non-progress-bar-frame has
    been rendered. Useful for queueing things to load in the background
    without elongating any current progress-bar-load.
    """
    return None


def android_get_external_files_dir() -> str:

    """(internal)

    Returns the android external storage path, or None if there is none on
    this device
    """
    return str()


def android_media_scan_file(file_name: str) -> None:

    """(internal)

    Refreshes Android MTP Index for a file; use this to get file
    modifications to be reflected in Android File Transfer.
    """
    return None


def android_show_wifi_settings() -> None:

    """(internal)"""
    return None


def app_instance_uuid() -> str:

    """(internal)"""
    return str()


def apply_config() -> None:

    """(internal)"""
    return None


def appname() -> str:

    """(internal)"""
    return str()


def appnameupper() -> str:

    """(internal)

    Return whether this build of the game can display full unicode such as
    Emoji, Asian languages, etc.
    """
    return str()


def back_press() -> None:

    """(internal)"""
    return None


def bless() -> None:

    """(internal)"""
    return None


def buttonwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    on_activate_call: Callable | None = None,
    label: str | ba.Lstr | None = None,
    color: Sequence[float] | None = None,
    down_widget: ba.Widget | None = None,
    up_widget: ba.Widget | None = None,
    left_widget: ba.Widget | None = None,
    right_widget: ba.Widget | None = None,
    texture: ba.Texture | None = None,
    text_scale: float | None = None,
    textcolor: Sequence[float] | None = None,
    enable_sound: bool | None = None,
    model_transparent: ba.Model | None = None,
    model_opaque: ba.Model | None = None,
    repeat: bool | None = None,
    scale: float | None = None,
    transition_delay: float | None = None,
    on_select_call: Callable | None = None,
    button_type: str | None = None,
    extra_touch_border_scale: float | None = None,
    selectable: bool | None = None,
    show_buffer_top: float | None = None,
    icon: ba.Texture | None = None,
    iconscale: float | None = None,
    icon_tint: float | None = None,
    icon_color: Sequence[float] | None = None,
    autoselect: bool | None = None,
    mask_texture: ba.Texture | None = None,
    tint_texture: ba.Texture | None = None,
    tint_color: Sequence[float] | None = None,
    tint2_color: Sequence[float] | None = None,
    text_flatness: float | None = None,
    text_res_scale: float | None = None,
    enabled: bool | None = None,
) -> ba.Widget:

    """Create or edit a button widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def camerashake(intensity: float = 1.0) -> None:

    """Shake the camera.

    Category: **Gameplay Functions**

    Note that some cameras and/or platforms (such as VR) may not display
    camera-shake, so do not rely on this always being visible to the
    player as a gameplay cue.
    """
    return None


def can_display_full_unicode() -> bool:

    """(internal)"""
    return bool()


def can_show_ad() -> bool:

    """(internal)"""
    return bool()


def capture_gamepad_input(call: Callable[[dict], None]) -> None:

    """(internal)

    Add a callable to be called for subsequent gamepad events.
    The method is passed a dict containing info about the event.
    """
    return None


def capture_keyboard_input(call: Callable[[dict], None]) -> None:

    """(internal)

    Add a callable to be called for subsequent keyboard-game-pad events.
    The method is passed a dict containing info about the event.
    """
    return None


def charstr(char_id: ba.SpecialChar) -> str:

    """Get a unicode string representing a special character.

    Category: **General Utility Functions**

    Note that these utilize the private-use block of unicode characters
    (U+E000-U+F8FF) and are specific to the game; exporting or rendering
    them elsewhere will be meaningless.

    See ba.SpecialChar for the list of available characters.
    """
    return str()


def chatmessage(
    message: str | ba.Lstr,
    clients: Sequence[int] | None = None,
    sender_override: str | None = None,
) -> None:

    """(internal)"""
    return None


def checkboxwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    text: str | ba.Lstr | None = None,
    value: bool | None = None,
    on_value_change_call: Callable[[bool], None] | None = None,
    on_select_call: Callable[[], None] | None = None,
    text_scale: float | None = None,
    textcolor: Sequence[float] | None = None,
    scale: float | None = None,
    is_radio_button: bool | None = None,
    maxwidth: float | None = None,
    autoselect: bool | None = None,
    color: Sequence[float] | None = None,
) -> ba.Widget:

    """Create or edit a check-box widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def client_info_query_response(token: str, response: Any) -> None:

    """(internal)"""
    return None


def clipboard_get_text() -> str:

    """Return text currently on the system clipboard.

    Category: **General Utility Functions**

    Ensure that ba.clipboard_has_text() returns True before calling
     this function.
    """
    return str()


def clipboard_has_text() -> bool:

    """Return whether there is currently text on the clipboard.

    Category: **General Utility Functions**

    This will return False if no system clipboard is available; no need
     to call ba.clipboard_is_supported() separately.
    """
    return bool()


def clipboard_is_supported() -> bool:

    """Return whether this platform supports clipboard operations at all.

    Category: **General Utility Functions**

    If this returns False, UIs should not show 'copy to clipboard'
    buttons, etc.
    """
    return bool()


def clipboard_set_text(value: str) -> None:

    """Copy a string to the system clipboard.

    Category: **General Utility Functions**

    Ensure that ba.clipboard_is_supported() returns True before adding
     buttons/etc. that make use of this functionality.
    """
    return None


def columnwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    background: bool | None = None,
    selected_child: ba.Widget | None = None,
    visible_child: ba.Widget | None = None,
    single_depth: bool | None = None,
    print_list_exit_instructions: bool | None = None,
    left_border: float | None = None,
    top_border: float | None = None,
    bottom_border: float | None = None,
    selection_loops_to_parent: bool | None = None,
    border: float | None = None,
    margin: float | None = None,
    claims_left_right: bool | None = None,
    claims_tab: bool | None = None,
) -> ba.Widget:

    """Create or edit a column widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def commit_config(config: str) -> None:

    """(internal)"""
    return None


def connect_to_party(
    address: str, port: int | None = None, print_progress: bool = True
) -> None:

    """(internal)"""
    return None


def console_print(*args: Any) -> None:

    """(internal)

    Print the provided args to the game console (using str()).
    For most debugging/info purposes you should just use Python's standard
    print, which will show up in the game console as well.
    """
    return None


def containerwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    background: bool | None = None,
    selected_child: ba.Widget | None = None,
    transition: str | None = None,
    cancel_button: ba.Widget | None = None,
    start_button: ba.Widget | None = None,
    root_selectable: bool | None = None,
    on_activate_call: Callable[[], None] | None = None,
    claims_left_right: bool | None = None,
    claims_tab: bool | None = None,
    selection_loops: bool | None = None,
    selection_loops_to_parent: bool | None = None,
    scale: float | None = None,
    on_outside_click_call: Callable[[], None] | None = None,
    single_depth: bool | None = None,
    visible_child: ba.Widget | None = None,
    stack_offset: Sequence[float] | None = None,
    color: Sequence[float] | None = None,
    on_cancel_call: Callable[[], None] | None = None,
    print_list_exit_instructions: bool | None = None,
    click_activate: bool | None = None,
    always_highlight: bool | None = None,
    selectable: bool | None = None,
    scale_origin_stack_offset: Sequence[float] | None = None,
    toolbar_visibility: str | None = None,
    on_select_call: Callable[[], None] | None = None,
    claim_outside_clicks: bool | None = None,
    claims_up_down: bool | None = None,
) -> ba.Widget:

    """Create or edit a container widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def contains_python_dist() -> bool:

    """(internal)"""
    return bool()


def debug_print_py_err() -> None:

    """(internal)

    Debugging func for tracking leaked Python errors in the C++ layer..
    """
    return None


def disconnect_client(client_id: int, ban_time: int = 300) -> bool:

    """(internal)"""
    return bool()


def disconnect_from_host() -> None:

    """(internal)

    Category: General Utility Functions
    """
    return None


def display_log(name: str, level: str, message: str) -> None:

    """(internal)

    Sends a log message to the in-game console and any per-platform
    log destinations (Android log, etc.). This generally is not called
    directly and should instead be fed Python logging output.
    """
    return None


def do_once() -> bool:

    """Return whether this is the first time running a line of code.

    Category: **General Utility Functions**

    This is used by 'print_once()' type calls to keep from overflowing
    logs. The call functions by registering the filename and line where
    The call is made from.  Returns True if this location has not been
    registered already, and False if it has.

    ##### Example
    This print will only fire for the first loop iteration:
    >>> for i in range(10):
    ... if ba.do_once():
    ...     print('Hello once from loop!')
    """
    return bool()


def ehv() -> None:

    """(internal)"""
    return None


def emitfx(
    position: Sequence[float],
    velocity: Sequence[float] | None = None,
    count: int = 10,
    scale: float = 1.0,
    spread: float = 1.0,
    chunk_type: str = 'rock',
    emit_type: str = 'chunks',
    tendril_type: str = 'smoke',
) -> None:

    """Emit particles, smoke, etc. into the fx sim layer.

    Category: **Gameplay Functions**

    The fx sim layer is a secondary dynamics simulation that runs in
    the background and just looks pretty; it does not affect gameplay.
    Note that the actual amount emitted may vary depending on graphics
    settings, exiting element counts, or other factors.
    """
    return None


def end_host_scanning() -> None:

    """(internal)

    Category: General Utility Functions
    """
    return None


def env() -> dict:

    """(internal)

    Returns a dict containing general info about the operating environment
    such as version, platform, etc.
    This info is now exposed through ba.App; refer to those docs for
    info on specific elements.
    """
    return dict()


def evaluate_lstr(value: str) -> str:

    """(internal)"""
    return str()


def fade_screen(
    to: int = 0, time: float = 0.25, endcall: Callable[[], None] | None = None
) -> None:

    """(internal)

    Fade the local game screen in our out from black over a duration of
    time. if "to" is 0, the screen will fade out to black.  Otherwise it
    will fade in from black. If endcall is provided, it will be run after a
    completely faded frame is drawn.
    """
    return None


def focus_window() -> None:

    """(internal)

    A workaround for some unintentional backgrounding that occurs on mac
    """
    return None


def get_appconfig_builtin_keys() -> list[str]:

    """(internal)"""
    return ['blah', 'blah2']


def get_appconfig_default_value(key: str) -> Any:

    """(internal)"""
    return _uninferrable()


def get_camera_position() -> tuple[float, ...]:

    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return (0.0, 0.0, 0.0)


def get_camera_target() -> tuple[float, ...]:

    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return (0.0, 0.0, 0.0)


def get_chat_messages() -> list[str]:

    """(internal)"""
    return ['blah', 'blah2']


def get_client_public_device_uuid(client_id: int) -> str | None:

    """(internal)

    Category: General Utility Functions

    Return a public device UUID for a client. If the client does not
    exist or is running a version older than 1.6.10, returns None.
    Public device UUID uniquely identifies the device the client is
    using in a semi-permanent way. The UUID value will change
    periodically with updates to the game or operating system.
    """
    return ''


def get_collision_info(*args: Any) -> Any:

    """Return collision related values

    Category: **Gameplay Functions**

    Returns a single collision value or tuple of values such as location,
    depth, nodes involved, etc. Only call this in the handler of a
    collision-triggered callback or message
    """
    return _uninferrable()


def get_configurable_game_pads() -> list:

    """(internal)

    Returns a list of the currently connected gamepads that can be
    configured.
    """
    return list()


def get_connection_to_host_info() -> dict:

    """(internal)"""
    return dict()


def get_display_resolution() -> tuple[int, int] | None:

    """(internal)

    Return the currently selected display resolution for fullscreen
    display. Returns None if resolutions cannot be directly set.
    """
    return (0, 0)


def get_foreground_host_activity() -> ba.Activity | None:

    """(internal)

    Returns the ba.Activity currently in the foreground, or None if there
    is none.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Activity(settings={})


def get_foreground_host_session() -> ba.Session | None:

    """(internal)

    Return the ba.Session currently being displayed, or None if there is
    none.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Session([])


def get_game_port() -> int:

    """(internal)

    Return the port ballistica is hosting on.
    """
    return int()


def get_game_roster() -> list[dict[str, Any]]:

    """(internal)"""
    return [{'foo': 'bar'}]


def get_idle_time() -> int:

    """(internal)

    Returns the amount of time since any game input has been received.
    """
    return int()


def get_local_active_input_devices_count() -> int:

    """(internal)"""
    return int()


def get_low_level_config_value(key: str, default_value: int) -> int:

    """(internal)"""
    return int()


def get_max_graphics_quality() -> str:

    """(internal)

    Return the max graphics-quality supported on the current hardware.
    """
    return str()


def get_package_collide_model(
    package: ba.AssetPackage, name: str
) -> ba.CollideModel:

    """(internal)"""
    import ba  # pylint: disable=cyclic-import

    return ba.CollideModel()


def get_package_data(package: ba.AssetPackage, name: str) -> ba.Data:

    """(internal)."""
    import ba  # pylint: disable=cyclic-import

    return ba.Data()


def get_package_model(package: ba.AssetPackage, name: str) -> ba.Model:

    """(internal)"""
    import ba  # pylint: disable=cyclic-import

    return ba.Model()


def get_package_sound(package: ba.AssetPackage, name: str) -> ba.Sound:

    """(internal)."""
    import ba  # pylint: disable=cyclic-import

    return ba.Sound()


def get_package_texture(package: ba.AssetPackage, name: str) -> ba.Texture:

    """(internal)"""
    import ba  # pylint: disable=cyclic-import

    return ba.Texture()


def get_public_party_enabled() -> bool:

    """(internal)"""
    return bool()


def get_public_party_max_size() -> int:

    """(internal)"""
    return int()


def get_qrcode_texture(url: str) -> ba.Texture:

    """(internal)"""
    import ba  # pylint: disable=cyclic-import

    return ba.Texture()


def get_random_names() -> list:

    """(internal)

    Returns the random names used by the game.
    """
    return list()


def get_replay_speed_exponent() -> int:

    """(internal)

    Returns current replay speed value. Actual displayed speed is pow(2,speed).
    """
    return int()


def get_replays_dir() -> str:

    """(internal)"""
    return str()


def get_special_widget(name: str) -> Widget:

    """(internal)"""
    return Widget()


def get_string_height(string: str, suppress_warning: bool = False) -> float:

    """(internal)

    Given a string, returns its height using the standard small app
    font.
    """
    return float()


def get_string_width(string: str, suppress_warning: bool = False) -> float:

    """(internal)

    Given a string, returns its width using the standard small app
    font.
    """
    return float()


def get_thread_name() -> str:

    """(internal)

    Returns the name of the current thread.
    This may vary depending on platform and should not be used in logic;
    only for debugging.
    """
    return str()


def get_ui_input_device() -> ba.InputDevice:

    """(internal)

    Returns the input-device that currently owns the user interface, or
    None if there is none.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.InputDevice()


def get_v1_cloud_log() -> str:

    """(internal)"""
    return str()


def get_v1_cloud_log_file_path() -> str:

    """(internal)

    Return the path to the app log file.
    """
    return str()


def get_volatile_data_directory() -> str:

    """(internal)

    Return the path to the app volatile data directory.
    This directory is for data generated by the app that does not
    need to be backed up and can be recreated if necessary.
    """
    return str()


# Show that our return type varies based on "doraise" value:
@overload
def getactivity(doraise: Literal[True] = True) -> ba.Activity:
    ...


@overload
def getactivity(doraise: Literal[False]) -> ba.Activity | None:
    ...


def getactivity(doraise: bool = True) -> ba.Activity | None:
    """Return the current ba.Activity instance.

    Category: **Gameplay Functions**

    Note that this is based on context; thus code run in a timer generated
    in Activity 'foo' will properly return 'foo' here, even if another
    Activity has since been created or is transitioning in.
    If there is no current Activity, raises a ba.ActivityNotFoundError.
    If doraise is False, None will be returned instead in that case.
    """
    return None


def getcollidemodel(name: str) -> ba.CollideModel:

    """Return a collide-model, loading it if necessary.

    Category: **Asset Functions**

    Collide-models are used in physics calculations for such things as
    terrain.

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.CollideModel()


def getdata(name: str) -> ba.Data:

    """Return a data, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Data()


# Show that our return type varies based on "doraise" value:
@overload
def getinputdevice(
    name: str, unique_id: str, doraise: Literal[True] = True
) -> ba.InputDevice:
    ...


@overload
def getinputdevice(
    name: str, unique_id: str, doraise: Literal[False]
) -> ba.InputDevice | None:
    ...


def getinputdevice(name: str, unique_id: str, doraise: bool = True) -> Any:
    """(internal)

    Given a type name and a unique identifier, returns an InputDevice.
    Throws an Exception if the input-device is not found, or returns None
    if 'doraise' is False.
    """
    return None


def getmodel(name: str) -> ba.Model:

    """Return a model, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Model()


def getnodes() -> list:

    """Return all nodes in the current ba.Context.

    Category: **Gameplay Functions**
    """
    return list()


# Show that our return type varies based on "doraise" value:
@overload
def getsession(doraise: Literal[True] = True) -> ba.Session:
    ...


@overload
def getsession(doraise: Literal[False]) -> ba.Session | None:
    ...


def getsession(doraise: bool = True) -> ba.Session | None:
    """Category: **Gameplay Functions**

    Returns the current ba.Session instance.
    Note that this is based on context; thus code being run in the UI
    context will return the UI context here even if a game Session also
    exists, etc. If there is no current Session, an Exception is raised, or
    if doraise is False then None is returned instead.
    """
    return None


def getsound(name: str) -> ba.Sound:

    """Return a sound, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Sound()


def gettexture(name: str) -> ba.Texture:

    """Return a texture, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Texture()


def has_gamma_control() -> bool:

    """(internal)

    Returns whether the system can adjust overall screen gamma)
    """
    return bool()


def has_user_run_commands() -> bool:

    """(internal)"""
    return bool()


def has_video_ads() -> bool:

    """(internal)"""
    return bool()


def have_chars(text: str) -> bool:

    """(internal)"""
    return bool()


def have_connected_clients() -> bool:

    """(internal)

    Category: General Utility Functions
    """
    return bool()


def have_incentivized_ad() -> bool:

    """(internal)"""
    return bool()


def have_permission(permission: ba.Permission) -> bool:

    """(internal)"""
    return bool()


def have_touchscreen_input() -> bool:

    """(internal)

    Returns whether or not a touch-screen input is present
    """
    return bool()


def host_scan_cycle() -> list:

    """(internal)"""
    return list()


def hscrollwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    background: bool | None = None,
    selected_child: ba.Widget | None = None,
    capture_arrows: bool | None = None,
    on_select_call: Callable[[], None] | None = None,
    center_small_content: bool | None = None,
    color: Sequence[float] | None = None,
    highlight: bool | None = None,
    border_opacity: float | None = None,
    simple_culling_h: float | None = None,
    claims_left_right: bool | None = None,
    claims_up_down: bool | None = None,
    claims_tab: bool | None = None,
) -> ba.Widget:

    """Create or edit a horizontal scroll widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def imagewidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    color: Sequence[float] | None = None,
    texture: ba.Texture | None = None,
    opacity: float | None = None,
    model_transparent: ba.Model | None = None,
    model_opaque: ba.Model | None = None,
    has_alpha_channel: bool = True,
    tint_texture: ba.Texture | None = None,
    tint_color: Sequence[float] | None = None,
    transition_delay: float | None = None,
    draw_controller: ba.Widget | None = None,
    tint2_color: Sequence[float] | None = None,
    tilt_scale: float | None = None,
    mask_texture: ba.Texture | None = None,
    radial_amount: float | None = None,
) -> ba.Widget:

    """Create or edit an image widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def in_logic_thread() -> bool:

    """(internal)

    Returns whether or not the current thread is the logic thread.
    """
    return bool()


def increment_analytics_count(name: str, increment: int = 1) -> None:

    """(internal)"""
    return None


def increment_analytics_count_raw_2(
    name: str, uses_increment: bool = True, increment: int = 1
) -> None:

    """(internal)"""
    return None


def increment_analytics_counts_raw(name: str, increment: int = 1) -> None:

    """(internal)"""
    return None


def is_in_replay() -> bool:

    """(internal)"""
    return bool()


def is_log_full() -> bool:

    """(internal)"""
    return bool()


def is_os_playing_music() -> bool:

    """(internal)

    Tells whether the OS is currently playing music of some sort.

    (Used to determine whether the game should avoid playing its own)
    """
    return bool()


def is_ouya_build() -> bool:

    """(internal)

    Returns whether we're running the ouya-specific version
    """
    return bool()


def is_party_icon_visible() -> bool:

    """(internal)"""
    return bool()


def is_running_on_fire_tv() -> bool:

    """(internal)"""
    return bool()


def is_running_on_ouya() -> bool:

    """(internal)"""
    return bool()


def is_xcode_build() -> bool:

    """(internal)"""
    return bool()


def lock_all_input() -> None:

    """(internal)

    Prevents all keyboard, mouse, and gamepad events from being processed.
    """
    return None


def mac_music_app_get_library_source() -> None:

    """(internal)"""
    return None


def mac_music_app_get_playlists() -> list[str]:

    """(internal)"""
    return ['blah', 'blah2']


def mac_music_app_get_volume() -> int:

    """(internal)"""
    return int()


def mac_music_app_init() -> None:

    """(internal)"""
    return None


def mac_music_app_play_playlist(playlist: str) -> bool:

    """(internal)"""
    return bool()


def mac_music_app_set_volume(volume: int) -> None:

    """(internal)"""
    return None


def mac_music_app_stop() -> None:

    """(internal)"""
    return None


def mark_log_sent() -> None:

    """(internal)"""
    return None


def music_player_play(files: Any) -> None:

    """(internal)

    Starts internal music file playback (for internal use)
    """
    return None


def music_player_set_volume(volume: float) -> None:

    """(internal)

    Sets internal music player volume (for internal use)
    """
    return None


def music_player_shutdown() -> None:

    """(internal)

    Finalizes internal music file playback (for internal use)
    """
    return None


def music_player_stop() -> None:

    """(internal)

    Stops internal music file playback (for internal use)
    """
    return None


def new_host_session(
    sessiontype: type[ba.Session], benchmark_type: str | None = None
) -> None:

    """(internal)"""
    return None


def new_replay_session(file_name: str) -> None:

    """(internal)"""
    return None


def newactivity(
    activity_type: type[ba.Activity], settings: dict | None = None
) -> ba.Activity:

    """Instantiates a ba.Activity given a type object.

    Category: **General Utility Functions**

    Activities require special setup and thus cannot be directly
    instantiated; you must go through this function.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Activity(settings={})


def newnode(
    type: str,
    owner: ba.Node | None = None,
    attrs: dict | None = None,
    name: str | None = None,
    delegate: Any = None,
) -> Node:

    """Add a node of the given type to the game.

    Category: **Gameplay Functions**

    If a dict is provided for 'attributes', the node's initial attributes
    will be set based on them.

    'name', if provided, will be stored with the node purely for debugging
    purposes. If no name is provided, an automatic one will be generated
    such as 'terrain@foo.py:30'.

    If 'delegate' is provided, Python messages sent to the node will go to
    that object's handlemessage() method. Note that the delegate is stored
    as a weak-ref, so the node itself will not keep the object alive.

    if 'owner' is provided, the node will be automatically killed when that
    object dies. 'owner' can be another node or a ba.Actor
    """
    return Node()


def open_dir_externally(path: str) -> None:

    """(internal)

    Open the provided dir in the default external app.
    """
    return None


def open_file_externally(path: str) -> None:

    """(internal)

    Open the provided file in the default external app.
    """
    return None


def open_url(address: str, force_internal: bool = False) -> None:

    """Open a provided URL.

    Category: **General Utility Functions**

    Open the provided url in a web-browser, or display the URL
    string in a window if that isn't possible (or if force_internal
    is True).
    """
    return None


def playsound(
    sound: Sound,
    volume: float = 1.0,
    position: Sequence[float] | None = None,
    host_only: bool = False,
) -> None:

    """Play a ba.Sound a single time.

    Category: **Gameplay Functions**

    If position is not provided, the sound will be at a constant volume
    everywhere. Position should be a float tuple of size 3.
    """
    return None


def print_context() -> None:

    """(internal)

    Prints info about the current context state; for debugging.
    """
    return None


def print_load_info() -> None:

    """(internal)

    Category: **General Utility Functions**
    """
    return None


def printnodes() -> None:

    """Print various info about existing nodes; useful for debugging.

    Category: **Gameplay Functions**
    """
    return None


def printobjects() -> None:

    """Print debugging info about game objects.

    Category: **General Utility Functions**

    This call only functions in debug builds of the game.
    It prints various info about the current object count, etc.
    """
    return None


def pushcall(
    call: Callable,
    from_other_thread: bool = False,
    suppress_other_thread_warning: bool = False,
    other_thread_use_fg_context: bool = False,
) -> None:

    """Pushes a call onto the event loop to be run during the next cycle.

    Category: **General Utility Functions**

    This can be handy for calls that are disallowed from within other
    callbacks, etc.

    This call expects to be used in the logic thread, and will automatically
    save and restore the ba.Context to behave seamlessly.

    If you want to push a call from outside of the logic thread,
    however, you can pass 'from_other_thread' as True. In this case
    the call will always run in the UI context on the logic thread
    or whichever context is in the foreground if
    other_thread_use_fg_context is True.
    """
    return None


def quit(soft: bool = False, back: bool = False) -> None:

    """Quit the game.

    Category: **General Utility Functions**

    On systems like android, 'soft' will end the activity but keep the
    app running.
    """
    return None


def register_activity(activity: ba.Activity) -> ActivityData:

    """(internal)"""
    return ActivityData()


def register_session(session: ba.Session) -> SessionData:

    """(internal)"""
    return SessionData()


def release_gamepad_input() -> None:

    """(internal)

    Resumes normal gamepad event processing.
    """
    return None


def release_keyboard_input() -> None:

    """(internal)

    Resumes normal keyboard event processing.
    """
    return None


def reload_media() -> None:

    """(internal)

    Reload all currently loaded game media; useful for
    development/debugging.
    """
    return None


def request_permission(permission: ba.Permission) -> None:

    """(internal)"""
    return None


def reset_game_activity_tracking() -> None:

    """(internal)"""
    return None


def reset_random_player_names() -> None:

    """(internal)"""
    return None


def resolve_appconfig_value(key: str) -> Any:

    """(internal)"""
    return _uninferrable()


def rowwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    background: bool | None = None,
    selected_child: ba.Widget | None = None,
    visible_child: ba.Widget | None = None,
    claims_left_right: bool | None = None,
    claims_tab: bool | None = None,
    selection_loops_to_parent: bool | None = None,
) -> ba.Widget:

    """Create or edit a row widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def safecolor(
    color: Sequence[float], target_intensity: float = 0.6
) -> tuple[float, ...]:

    """Given a color tuple, return a color safe to display as text.

    Category: **General Utility Functions**

    Accepts tuples of length 3 or 4. This will slightly brighten very
    dark colors, etc.
    """
    return (0.0, 0.0, 0.0)


def screenmessage(
    message: str | ba.Lstr,
    color: Sequence[float] | None = None,
    top: bool = False,
    image: dict[str, Any] | None = None,
    log: bool = False,
    clients: Sequence[int] | None = None,
    transient: bool = False,
) -> None:

    """Print a message to the local client's screen, in a given color.

    Category: **General Utility Functions**

    If 'top' is True, the message will go to the top message area.
    For 'top' messages, 'image' must be a dict containing 'texture'
    and 'tint_texture' textures and 'tint_color' and 'tint2_color'
    colors. This defines an icon to display alongside the message.
    If 'log' is True, the message will also be submitted to the log.
    'clients' can be a list of client-ids the message should be sent
    to, or None to specify that everyone should receive it.
    If 'transient' is True, the message will not be included in the
    game-stream and thus will not show up when viewing replays.
    Currently the 'clients' option only works for transient messages.
    """
    return None


def scrollwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    background: bool | None = None,
    selected_child: ba.Widget | None = None,
    capture_arrows: bool = False,
    on_select_call: Callable | None = None,
    center_small_content: bool | None = None,
    color: Sequence[float] | None = None,
    highlight: bool | None = None,
    border_opacity: float | None = None,
    simple_culling_v: float | None = None,
    selection_loops_to_parent: bool | None = None,
    claims_left_right: bool | None = None,
    claims_up_down: bool | None = None,
    claims_tab: bool | None = None,
    autoselect: bool | None = None,
) -> ba.Widget:

    """Create or edit a scroll widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import

    return ba.Widget()


def set_admins(admins: list[str]) -> None:

    """(internal)"""
    return None


def set_analytics_screen(screen: str) -> None:

    """Used for analytics to see where in the app players spend their time.

    Category: **General Utility Functions**

    Generally called when opening a new window or entering some UI.
    'screen' should be a string description of an app location
    ('Main Menu', etc.)
    """
    return None


def set_authenticate_clients(enable: bool) -> None:

    """(internal)"""
    return None


def set_camera_manual(value: bool) -> None:

    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return None


def set_camera_position(x: float, y: float, z: float) -> None:

    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return None


def set_camera_target(x: float, y: float, z: float) -> None:

    """(internal)

    WARNING: these camera controls will not apply to network clients
    and may behave unpredictably in other ways. Use them only for
    tinkering.
    """
    return None


def set_debug_speed_exponent(speed: int) -> None:

    """(internal)

    Sets the debug speed scale for the game. Actual speed is pow(2,speed).
    """
    return None


def set_enable_default_kick_voting(enable: bool) -> None:

    """(internal)"""
    return None


def set_internal_language_keys(
    listobj: list[tuple[str, str]], random_names_list: list[tuple[str, str]]
) -> None:

    """(internal)"""
    return None


def set_low_level_config_value(key: str, value: int) -> None:

    """(internal)"""
    return None


def set_map_bounds(
    bounds: tuple[float, float, float, float, float, float]
) -> None:

    """(internal)

    Set map bounds. Generally nodes that go outside of this box are killed.
    """
    return None


def set_master_server_source(source: int) -> None:

    """(internal)"""
    return None


def set_party_icon_always_visible(value: bool) -> None:

    """(internal)"""
    return None


def set_party_window_open(value: bool) -> None:

    """(internal)"""
    return None


def set_platform_misc_read_vals(mode: str) -> None:

    """(internal)"""
    return None


def set_public_party_enabled(enabled: bool) -> None:

    """(internal)"""
    return None


def set_public_party_max_size(max_size: int) -> None:

    """(internal)"""
    return None


def set_public_party_name(name: str) -> None:

    """(internal)"""
    return None


def set_public_party_stats_url(url: str | None) -> None:

    """(internal)"""
    return None


def set_replay_speed_exponent(speed: int) -> None:

    """(internal)

    Set replay speed. Actual displayed speed is pow(2, speed).
    """
    return None


def set_stress_testing(testing: bool, player_count: int) -> None:

    """(internal)"""
    return None


def set_telnet_access_enabled(enable: bool) -> None:

    """(internal)"""
    return None


def set_thread_name(name: str) -> None:

    """(internal)

    Sets the name of the current thread (on platforms where this is
    available). Thread names are only for debugging and should not be
    used in logic, as naming behavior can vary across platforms.
    """
    return None


def set_touchscreen_editing(editing: bool) -> None:

    """(internal)"""
    return None


def set_ui_input_device(input_device: ba.InputDevice | None) -> None:

    """(internal)

    Sets the input-device that currently owns the user interface.
    """
    return None


def setup_sigint() -> None:

    """(internal)"""
    return None


def show_ad(
    purpose: str, on_completion_call: Callable[[], None] | None = None
) -> None:

    """(internal)"""
    return None


def show_ad_2(
    purpose: str, on_completion_call: Callable[[bool], None] | None = None
) -> None:

    """(internal)"""
    return None


def show_app_invite(
    title: str | ba.Lstr, message: str | ba.Lstr, code: str
) -> None:

    """(internal)

    Category: **General Utility Functions**
    """
    return None


def show_online_score_ui(
    show: str = 'general',
    game: str | None = None,
    game_version: str | None = None,
) -> None:

    """(internal)"""
    return None


def show_progress_bar() -> None:

    """(internal)

    Category: **General Utility Functions**
    """
    return None


def submit_analytics_counts() -> None:

    """(internal)"""
    return None


def textwidget(
    edit: ba.Widget | None = None,
    parent: ba.Widget | None = None,
    size: Sequence[float] | None = None,
    position: Sequence[float] | None = None,
    text: str | ba.Lstr | None = None,
    v_align: str | None = None,
    h_align: str | None = None,
    editable: bool | None = None,
    padding: float | None = None,
    on_return_press_call: Callable[[], None] | None = None,
    on_activate_call: Callable[[], None] | None = None,
    selectable: bool | None = None,
    query: ba.Widget | None = None,
    max_chars: int | None = None,
    color: Sequence[float] | None = None,
    click_activate: bool | None = None,
    on_select_call: Callable[[], None] | None = None,
    always_highlight: bool | None = None,
    draw_controller: ba.Widget | None = None,
    scale: float | None = None,
    corner_scale: float | None = None,
    description: str | ba.Lstr | None = None,
    transition_delay: float | None = None,
    maxwidth: float | None = None,
    max_height: float | None = None,
    flatness: float | None = None,
    shadow: float | None = None,
    autoselect: bool | None = None,
    rotate: float | None = None,
    enabled: bool | None = None,
    force_internal_editing: bool | None = None,
    always_show_carat: bool | None = None,
    big: bool | None = None,
    extra_touch_border_scale: float | None = None,
    res_scale: float | None = None,
) -> Widget:

    """Create or edit a text widget.

    Category: **User Interface Functions**

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    return Widget()


# Overloads to return a type based on requested format.


@overload
def time(
    timetype: ba.TimeType = TimeType.SIM,
    timeformat: Literal[TimeFormat.SECONDS] = TimeFormat.SECONDS,
) -> float:
    ...


# This "*" keyword-only hack lets us accept 1 arg (timeformat=MILLISECS) forms.
@overload
def time(
    timetype: ba.TimeType = TimeType.SIM,
    *,
    timeformat: Literal[TimeFormat.MILLISECONDS],
) -> int:
    ...


@overload
def time(
    timetype: ba.TimeType, timeformat: Literal[TimeFormat.MILLISECONDS]
) -> int:
    ...


def time(
    timetype: ba.TimeType = TimeType.SIM,
    timeformat: ba.TimeFormat = TimeFormat.SECONDS,
) -> Any:

    """Return the current time.

    Category: **General Utility Functions**

    The time returned depends on the current ba.Context and timetype.

    timetype can be either SIM, BASE, or REAL. It defaults to
    SIM. Types are explained below:

    - SIM time maps to local simulation time in ba.Activity or ba.Session
    Contexts. This means that it may progress slower in slow-motion play
    modes, stop when the game is paused, etc.  This time type is not
    available in UI contexts.
    - BASE time is also linked to gameplay in ba.Activity or ba.Session
    Contexts, but it progresses at a constant rate regardless of
     slow-motion states or pausing.  It can, however, slow down or stop
    in certain cases such as network outages or game slowdowns due to
    cpu load. Like 'sim' time, this is unavailable in UI contexts.
    - REAL time always maps to actual clock time with a bit of filtering
    added, regardless of Context. (The filtering prevents it from going
    backwards or jumping forward by large amounts due to the app being
    backgrounded, system time changing, etc.)
    Real time timers are currently only available in the UI context.

    The 'timeformat' arg defaults to SECONDS which returns float seconds,
    but it can also be MILLISECONDS to return integer milliseconds.

    Note: If you need pure unfiltered clock time, just use the standard
    Python functions such as time.time().
    """
    return None


def time_format_check(time_format: ba.TimeFormat, length: float | int) -> None:

    """(internal)

    Logs suspicious time values for timers or animate calls.

    (for helping with the transition from milliseconds-based time calls
    to seconds-based ones)
    """
    return None


def timer(
    time: float,
    call: Callable[[], Any],
    repeat: bool = False,
    timetype: ba.TimeType = TimeType.SIM,
    timeformat: ba.TimeFormat = TimeFormat.SECONDS,
    suppress_format_warning: bool = False,
) -> None:

    """Schedule a call to run at a later point in time.

    Category: **General Utility Functions**

    This function adds a timer to the current ba.Context.
    This timer cannot be canceled or modified once created. If you
     require the ability to do so, use the ba.Timer class instead.

    ##### Arguments
    ###### time (float)
    > Length of time (in seconds by default) that the timer will wait
    before firing. Note that the actual delay experienced may vary
     depending on the timetype. (see below)

    ###### call (Callable[[], Any])
    > A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as ba.WeakCall if that is not
    desired.

    ###### repeat (bool)
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ###### timetype (ba.TimeType)
    > Can be either `SIM`, `BASE`, or `REAL`. It defaults to
    `SIM`.

    ###### timeformat (ba.TimeFormat)
    > Defaults to seconds but can also be milliseconds.

    - SIM time maps to local simulation time in ba.Activity or ba.Session
    Contexts. This means that it may progress slower in slow-motion play
    modes, stop when the game is paused, etc.  This time type is not
    available in UI contexts.
    - BASE time is also linked to gameplay in ba.Activity or ba.Session
    Contexts, but it progresses at a constant rate regardless of
     slow-motion states or pausing.  It can, however, slow down or stop
    in certain cases such as network outages or game slowdowns due to
    cpu load. Like 'sim' time, this is unavailable in UI contexts.
    - REAL time always maps to actual clock time with a bit of filtering
    added, regardless of Context. (The filtering prevents it from going
    backwards or jumping forward by large amounts due to the app being
    backgrounded, system time changing, etc.)
    Real time timers are currently only available in the UI context.

    ##### Examples
    Print some stuff through time:
    >>> ba.screenmessage('hello from now!')
    >>> ba.timer(1.0, ba.Call(ba.screenmessage, 'hello from the future!'))
    >>> ba.timer(2.0, ba.Call(ba.screenmessage,
    ...                       'hello from the future 2!'))
    """
    return None


def uibounds() -> tuple[float, float, float, float]:

    """(internal)

    Returns a tuple of 4 values: (x-min, x-max, y-min, y-max) representing
    the range of values that can be plugged into a root level
    ba.ContainerWidget's stack_offset value while guaranteeing that its
    center remains onscreen.
    """
    return (0.0, 0.0, 0.0, 0.0)


def unlock_all_input() -> None:

    """(internal)

    Resumes normal keyboard, mouse, and gamepad event processing.
    """
    return None


def user_ran_commands() -> None:

    """(internal)"""
    return None


def v1_cloud_log(message: str) -> None:

    """(internal)

    Push messages to the old v1 cloud log.
    """
    return None


def value_test(
    arg: str, change: float | None = None, absolute: float | None = None
) -> float:

    """(internal)"""
    return float()


def widget(
    edit: ba.Widget | None = None,
    up_widget: ba.Widget | None = None,
    down_widget: ba.Widget | None = None,
    left_widget: ba.Widget | None = None,
    right_widget: ba.Widget | None = None,
    show_buffer_top: float | None = None,
    show_buffer_bottom: float | None = None,
    show_buffer_left: float | None = None,
    show_buffer_right: float | None = None,
    autoselect: bool | None = None,
) -> None:

    """Edit common attributes of any widget.

    Category: **User Interface Functions**

    Unlike other UI calls, this can only be used to edit, not to create.
    """
    return None


def workspaces_in_use() -> bool:

    """(internal)

    Returns whether workspaces functionality has been enabled at
    any point this run.
    """
    return bool()
