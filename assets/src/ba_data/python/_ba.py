# Copyright (c) 2011-2020 Eric Froemling
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----------------------------------------------------------------------------
"""A dummy stub module for the real _ba.

The real _ba is a compiled extension module and only available
in the live game. This dummy module allows Pylint/Mypy/etc. to
function reasonably well outside of the game.

Make sure this file is never included in an actual game distro!

Ideally this should be a stub (.pyi) file, but we'd need
to make sure that it still works with all our tools
(mypy, pylint, pycharm).

NOTE: This file was autogenerated by gendummymodule; do not edit by hand.
"""

# (hash we can use to see if this file is out of date)
# SOURCES_HASH=188869443842417703663502065018427831709

# I'm sorry Pylint. I know this file saddens you. Be strong.
# pylint: disable=useless-suppression
# pylint: disable=unnecessary-pass
# pylint: disable=unused-argument
# pylint: disable=missing-docstring
# pylint: disable=too-many-locals
# pylint: disable=redefined-builtin
# pylint: disable=too-many-lines
# pylint: disable=redefined-outer-name
# pylint: disable=invalid-name
# pylint: disable=no-self-use
# pylint: disable=no-value-for-parameter

from __future__ import annotations

from typing import TYPE_CHECKING, overload, Sequence, TypeVar

from ba._enums import TimeFormat, TimeType

if TYPE_CHECKING:
    from typing import (Any, Dict, Callable, Tuple, List, Optional, Union,
                        List, Type)
    from typing_extensions import Literal
    from ba._app import App
    import ba

_T = TypeVar('_T')

app: App


def _uninferrable() -> Any:
    """Get an "Any" in mypy and "uninferrable" in Pylint."""
    # pylint: disable=undefined-variable
    return _not_a_real_variable  # type: ignore


class ActivityData:
    """(internal)"""

    def exists(self) -> bool:
        """exists() -> bool

        Returns whether the ActivityData still exists.
        Most functionality will fail on a nonexistent instance.
        """
        return bool()

    def expire(self) -> None:
        """expire() -> None

        Expires the internal data for the activity
        """
        return None

    def make_foreground(self) -> None:
        """make_foreground() -> None

        Sets this activity as the foreground one in its session.
        """
        return None

    def start(self) -> None:
        """start() -> None

        Begins the activity running
        """
        return None


class CollideModel:
    """A reference to a collide-model.

    Category: Asset Classes

    Use ba.getcollidemodel() to instantiate one.
    """
    pass


class Context:
    """Context(source: Any)

    A game context state.

    Category: General Utility Classes

    Many operations such as ba.newnode() or ba.gettexture() operate
    implicitly on the current context. Each ba.Activity has its own
    Context and objects within that activity (nodes, media, etc) can only
    interact with other objects from that context.

    In general, as a modder, you should not need to worry about contexts,
    since timers and other callbacks will take care of saving and
    restoring the context automatically, but there may be rare cases where
    you need to deal with them, such as when loading media in for use in
    the UI (there is a special 'ui' context for all user-interface-related
    functionality)

    When instantiating a ba.Context instance, a single 'source' argument
    is passed, which can be one of the following strings/objects:

    'empty':
      Gives an empty context; it can be handy to run code here to ensure
      it does no loading of media, creation of nodes, etc.

    'current':
      Sets the context object to the current context.

    'ui':
      Sets to the UI context. UI functions as well as loading of media to
      be used in said functions must happen in the UI context.

    a ba.Activity instance:
      Gives the context for the provided ba.Activity.
      Most all code run during a game happens in an Activity's Context.

    a ba.Session instance:
      Gives the context for the provided ba.Session.
      Generally a user should not need to run anything here.


    Usage:

    Contexts are generally used with the python 'with' statement, which
    sets the context as current on entry and resets it to the previous
    value on exit.

    # Example: load a few textures into the UI context
    # (for use in widgets, etc):
    with ba.Context('ui'):
       tex1 = ba.gettexture('foo_tex_1')
       tex2 = ba.gettexture('foo_tex_2')
    """

    def __init__(self, source: Any):
        pass

    def __enter__(self) -> None:
        """Support for "with" statement."""
        pass

    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
        """Support for "with" statement."""
        pass


class ContextCall:
    """ContextCall(call: Callable)

    A context-preserving callable.

    Category: General Utility Classes

    A ContextCall wraps a callable object along with a reference
    to the current context (see ba.Context); it handles restoring the
    context when run and automatically clears itself if the context
    it belongs to shuts down.

    Generally you should not need to use this directly; all standard
    Ballistica callbacks involved with timers, materials, UI functions,
    etc. handle this under-the-hood you don't have to worry about it.
    The only time it may be necessary is if you are implementing your
    own callbacks, such as a worker thread that does some action and then
    runs some game code when done. By wrapping said callback in one of
    these, you can ensure that you will not inadvertently be keeping the
    current activity alive or running code in a torn-down (expired)
    context.

    You can also use ba.WeakCall for similar functionality, but
    ContextCall has the added bonus that it will not run during context
    shutdown, whereas ba.WeakCall simply looks at whether the target
    object still exists.

    # example A: code like this can inadvertently prevent our activity
    # (self) from ending until the operation completes, since the bound
    # method we're passing (self.dosomething) contains a strong-reference
    # to self).
    start_some_long_action(callback_when_done=self.dosomething)

    # example B: in this case our activity (self) can still die
    # properly; the callback will clear itself when the activity starts
    # shutting down, becoming a harmless no-op and releasing the reference
    # to our activity.
    start_long_action(callback_when_done=ba.ContextCall(self.mycallback))
    """

    def __init__(self, call: Callable):
        pass


class Data:
    """A reference to a data object.

    Category: Asset Classes

    Use ba.getdata() to instantiate one.
    """

    def getvalue(self) -> Any:
        """getvalue() -> Any

        Return the data object's value.

        This can consist of anything representable by json (dicts, lists,
        numbers, bools, None, etc).
        Note that this call will block if the data has not yet been loaded,
        so it can be beneficial to plan a short bit of time between when
        the data object is requested and when it's value is accessed.
        """
        return _uninferrable()


class InputDevice:
    """An input-device such as a gamepad, touchscreen, or keyboard.

    Category: Gameplay Classes

    Attributes:

       allows_configuring: bool
          Whether the input-device can be configured.

       player: Optional[ba.SessionPlayer]
          The player associated with this input device.

       client_id: int
          The numeric client-id this device is associated with.
          This is only meaningful for remote client inputs; for
          all local devices this will be -1.

       name: str
          The name of the device.

       unique_identifier: str
          A string that can be used to persistently identify the device,
          even among other devices of the same type. Used for saving
          prefs, etc.

       id: int
          The unique numeric id of this device.

       instance_number: int
          The number of this device among devices of the same type.

       is_controller_app: bool
          Whether this input-device represents a locally-connected
          controller-app.

       is_remote_client: bool
          Whether this input-device represents a remotely-connected
          client.

    """
    allows_configuring: bool
    player: Optional[ba.SessionPlayer]
    client_id: int
    name: str
    unique_identifier: str
    id: int
    instance_number: int
    is_controller_app: bool
    is_remote_client: bool

    def exists(self) -> bool:
        """exists() -> bool

        Return whether the underlying device for this object is still present.
        """
        return bool()

    def get_account_name(self, full: bool) -> str:
        """get_account_name(full: bool) -> str

        Returns the account name associated with this device.

        (can be used to get account names for remote players)
        """
        return str()

    def get_axis_name(self, axis_id: int) -> str:
        """get_axis_name(axis_id: int) -> str

        Given an axis ID, returns the name of the axis on this device.
        """
        return str()

    def get_button_name(self, button_id: int) -> str:
        """get_button_name(button_id: int) -> str

        Given a button ID, returns the name of the key/button on this device.
        """
        return str()

    def get_default_player_name(self) -> str:
        """get_default_player_name() -> str

        (internal)

        Returns the default player name for this device. (used for the 'random'
        profile)
        """
        return str()

    def get_player_profiles(self) -> dict:
        """get_player_profiles() -> dict

        (internal)
        """
        return dict()

    def is_connected_to_remote_player(self) -> bool:
        """is_connected_to_remote_player() -> bool

        (internal)
        """
        return bool()

    def remove_remote_player_from_game(self) -> None:
        """remove_remote_player_from_game() -> None

        (internal)
        """
        return None


class Material:
    """Material(label: str = None)

    An entity applied to game objects to modify collision behavior.

    Category: Gameplay Classes

    A material can affect physical characteristics, generate sounds,
    or trigger callback functions when collisions occur.

    Materials are applied to 'parts', which are groups of one or more
    rigid bodies created as part of a ba.Node.  Nodes can have any number
    of parts, each with its own set of materials. Generally materials are
    specified as array attributes on the Node. The 'spaz' node, for
    example, has various attributes such as 'materials',
    'roller_materials', and 'punch_materials', which correspond to the
    various parts it creates.

    Use ba.Material() to instantiate a blank material, and then use its
    add_actions() method to define what the material does.

    Attributes:

        label: str
            A label for the material; only used for debugging.
    """

    def __init__(self, label: str = None):
        pass

    label: str

    def add_actions(self,
                    actions: Tuple,
                    conditions: Optional[Tuple] = None) -> None:
        """add_actions(actions: Tuple, conditions: Optional[Tuple] = None)
          -> None

        Add one or more actions to the material, optionally with conditions.

        Conditions:

        Conditions are provided as tuples which can be combined to form boolean
        logic. A single condition might look like ('condition_name', cond_arg),
        or a more complex nested one might look like (('some_condition',
        cond_arg), 'or', ('another_condition', cond2_arg)).

        'and', 'or', and 'xor' are available to chain together 2 conditions, as
          seen above.

        Available Conditions:

        ('they_have_material', material) - does the part we're hitting have a
          given ba.Material?

        ('they_dont_have_material', material) - does the part we're hitting
          not have a given ba.Material?

        ('eval_colliding') - is 'collide' true at this point in material
          evaluation? (see the modify_part_collision action)

        ('eval_not_colliding') - is 'collide' false at this point in material
          evaluation? (see the modify_part_collision action)

        ('we_are_younger_than', age) - is our part younger than 'age'
          (in milliseconds)?

        ('we_are_older_than', age) - is our part older than 'age'
          (in milliseconds)?

        ('they_are_younger_than', age) - is the part we're hitting younger than
          'age' (in milliseconds)?

        ('they_are_older_than', age) - is the part we're hitting older than
          'age' (in milliseconds)?

        ('they_are_same_node_as_us') - does the part we're hitting belong to
          the same ba.Node as us?

        ('they_are_different_node_than_us') - does the part we're hitting
          belong to a different ba.Node than us?

        Actions:

        In a similar manner, actions are specified as tuples. Multiple actions
        can be specified by providing a tuple of tuples.

        Available Actions:

        ('call', when, callable) - calls the provided callable; 'when' can be
          either 'at_connect' or 'at_disconnect'. 'at_connect' means to fire
          when the two parts first come in contact; 'at_disconnect' means to
          fire once they cease being in contact.

        ('message', who, when, message_obj) - sends a message object; 'who' can
          be either 'our_node' or 'their_node', 'when' can be 'at_connect' or
          'at_disconnect', and message_obj is the message object to send.
          This has the same effect as calling the node's handlemessage()
          method.

        ('modify_part_collision', attr, value) - changes some characteristic
          of the physical collision that will occur between our part and their
          part.  This change will remain in effect as long as the two parts
          remain overlapping. This means if you have a part with a material
          that turns 'collide' off against parts younger than 100ms, and it
          touches another part that is 50ms old, it will continue to not
          collide with that part until they separate, even if the 100ms
          threshold is passed. Options for attr/value are: 'physical' (boolean
          value; whether a *physical* response will occur at all), 'friction'
          (float value; how friction-y the physical response will be),
          'collide' (boolean value; whether *any* collision will occur at all,
          including non-physical stuff like callbacks), 'use_node_collide'
          (boolean value; whether to honor modify_node_collision overrides for
          this collision), 'stiffness' (float value, how springy the physical
          response is), 'damping' (float value, how damped the physical
          response is), 'bounce' (float value; how bouncy the physical response
          is).

        ('modify_node_collision', attr, value) - similar to
          modify_part_collision, but operates at a node-level.
          collision attributes set here will remain in effect as long as
          *anything* from our part's node and their part's node overlap.
          A key use of this functionality is to prevent new nodes from
          colliding with each other if they appear overlapped;
          if modify_part_collision is used, only the individual parts that
          were overlapping would avoid contact, but other parts could still
          contact leaving the two nodes 'tangled up'.  Using
          modify_node_collision ensures that the nodes must completely
          separate before they can start colliding.  Currently the only attr
          available here is 'collide' (a boolean value).

        ('sound', sound, volume) - plays a ba.Sound when a collision occurs, at
          a given volume, regardless of the collision speed/etc.

        ('impact_sound', sound, targetImpulse, volume) - plays a sound when a
          collision occurs, based on the speed of impact. Provide a ba.Sound, a
          target-impulse, and a volume.

        ('skid_sound', sound, targetImpulse, volume) - plays a sound during a
          collision when parts are 'scraping' against each other. Provide a
          ba.Sound, a target-impulse, and a volume.

        ('roll_sound', sound, targetImpulse, volume) - plays a sound during a
          collision when parts are 'rolling' against each other. Provide a
          ba.Sound, a target-impulse, and a volume.

        # example 1: create a material that lets us ignore
        # collisions against any nodes we touch in the first
        # 100 ms of our existence; handy for preventing us from
        # exploding outward if we spawn on top of another object:
        m = ba.Material()
        m.add_actions(conditions=(('we_are_younger_than', 100),
                                 'or',('they_are_younger_than', 100)),
                     actions=('modify_node_collision', 'collide', False))

        # example 2: send a DieMessage to anything we touch, but cause
        # no physical response.  This should cause any ba.Actor to drop dead:
        m = ba.Material()
        m.add_actions(actions=(('modify_part_collision', 'physical', False),
                              ('message', 'their_node', 'at_connect',
                               ba.DieMessage())))

        # example 3: play some sounds when we're contacting the ground:
        m = ba.Material()
        m.add_actions(conditions=('they_have_material',
                                  shared.footing_material),
                      actions=(('impact_sound', ba.getsound('metalHit'), 2, 5),
                               ('skid_sound', ba.getsound('metalSkid'), 2, 5)))

        """
        return None


class Model:
    """A reference to a model.

    Category: Asset Classes

    Models are used for drawing.
    Use ba.getmodel() to instantiate one.
    """
    pass


class Node:
    """Reference to a Node; the low level building block of the game.

    Category: Gameplay Classes

    At its core, a game is nothing more than a scene of Nodes
    with attributes getting interconnected or set over time.

    A ba.Node instance should be thought of as a weak-reference
    to a game node; *not* the node itself. This means a Node's
    lifecycle is completely independent of how many Python references
    to it exist. To explicitly add a new node to the game, use
    ba.newnode(), and to explicitly delete one, use ba.Node.delete().
    ba.Node.exists() can be used to determine if a Node still points to
    a live node in the game.

    You can use ba.Node(None) to instantiate an invalid
    Node reference (sometimes used as attr values/etc).
    """

    # Adding attrs as needed.
    # FIXME: These should be instance attrs.
    # NOTE: Am just adding all possible node attrs here.
    # It would be nicer to make a distinct class for each
    # node type at some point so we get better type checks.
    color: Sequence[float] = (0.0, 0.0, 0.0)
    size: Sequence[float] = (0.0, 0.0, 0.0)
    position: Sequence[float] = (0.0, 0.0, 0.0)
    position_forward: Sequence[float] = (0.0, 0.0, 0.0)
    punch_position: Sequence[float] = (0.0, 0.0, 0.0)
    punch_velocity: Sequence[float] = (0.0, 0.0, 0.0)
    velocity: Sequence[float] = (0.0, 0.0, 0.0)
    name_color: Sequence[float] = (0.0, 0.0, 0.0)
    tint_color: Sequence[float] = (0.0, 0.0, 0.0)
    tint2_color: Sequence[float] = (0.0, 0.0, 0.0)
    text: Union[ba.Lstr, str] = ''
    texture: Optional[ba.Texture] = None
    tint_texture: Optional[ba.Texture] = None
    times: Sequence[int] = (1, 2, 3, 4, 5)
    values: Sequence[float] = (1.0, 2.0, 3.0, 4.0)
    offset: float = 0.0
    input0: float = 0.0
    input1: float = 0.0
    input2: float = 0.0
    input3: float = 0.0
    flashing: bool = False
    scale: Union[float, Sequence[float]] = 0.0
    opacity: float = 0.0
    loop: bool = False
    time1: int = 0
    time2: int = 0
    timemax: int = 0
    client_only: bool = False
    materials: Sequence[Material] = ()
    roller_materials: Sequence[Material] = ()
    name: str = ''
    punch_materials: Sequence[ba.Material] = ()
    pickup_materials: Sequence[ba.Material] = ()
    extras_material: Sequence[ba.Material] = ()
    rotate: float = 0.0
    hold_node: Optional[ba.Node] = None
    hold_body: int = 0
    host_only: bool = False
    premultiplied: bool = False
    source_player: Optional[ba.Player] = None
    model_opaque: Optional[ba.Model] = None
    model_transparent: Optional[ba.Model] = None
    damage_smoothed: float = 0.0
    punch_power: float = 0.0
    punch_momentum_linear: Sequence[float] = (0.0, 0.0, 0.0)
    punch_momentum_angular: float = 0.0
    rate: int = 0
    vr_depth: float = 0.0
    is_area_of_interest: bool = False
    jump_pressed: bool = False
    pickup_pressed: bool = False
    punch_pressed: bool = False
    bomb_pressed: bool = False
    fly_pressed: bool = False
    hold_position_pressed: bool = False
    knockout: float = 0.0
    invincible: bool = False
    stick_to_owner: bool = False
    damage: int = 0
    run: float = 0.0
    move_up_down: float = 0.0
    move_left_right: float = 0.0
    curse_death_time: int = 0
    boxing_gloves: bool = False
    use_fixed_vr_overlay: bool = False
    allow_kick_idle_players: bool = False
    music_continuous: bool = False
    music_count: int = 0
    hurt: float = 0.0
    always_show_health_bar: bool = False
    mini_billboard_1_texture: Optional[ba.Texture] = None
    mini_billboard_1_start_time: int = 0
    mini_billboard_1_end_time: int = 0
    mini_billboard_2_texture: Optional[ba.Texture] = None
    mini_billboard_2_start_time: int = 0
    mini_billboard_2_end_time: int = 0
    mini_billboard_3_texture: Optional[ba.Texture] = None
    mini_billboard_3_start_time: int = 0
    mini_billboard_3_end_time: int = 0
    boxing_gloves_flashing: bool = False
    dead: bool = False
    floor_reflection: bool = False
    debris_friction: float = 0.0
    debris_kill_height: float = 0.0
    vr_near_clip: float = 0.0
    shadow_ortho: bool = False
    happy_thoughts_mode: bool = False
    shadow_offset: Sequence[float] = (0.0, 0.0)
    paused: bool = False
    time: int = 0
    ambient_color: Sequence[float] = (1.0, 1.0, 1.0)
    camera_mode: str = 'rotate'
    frozen: bool = False
    area_of_interest_bounds: Sequence[float] = (-1, -1, -1, 1, 1, 1)
    shadow_range: Sequence[float] = (0, 0, 0, 0)
    counter_text: str = ''
    counter_texture: Optional[ba.Texture] = None
    shattered: int = 0
    billboard_texture: Optional[ba.Texture] = None
    billboard_cross_out: bool = False
    billboard_opacity: float = 0.0
    slow_motion: bool = False
    music: str = ''
    vr_camera_offset: Sequence[float] = (0.0, 0.0, 0.0)
    vr_overlay_center: Sequence[float] = (0.0, 0.0, 0.0)
    vr_overlay_center_enabled: bool = False
    vignette_outer: Sequence[float] = (0.0, 0.0)
    vignette_inner: Sequence[float] = (0.0, 0.0)
    tint: Sequence[float] = (1.0, 1.0, 1.0)

    def add_death_action(self, action: Callable[[], None]) -> None:
        """add_death_action(action: Callable[[], None]) -> None

        Add a callable object to be called upon this node's death.
        Note that these actions are run just after the node dies, not before.
        """
        return None

    def connectattr(self, srcattr: str, dstnode: Node, dstattr: str) -> None:
        """connectattr(srcattr: str, dstnode: Node, dstattr: str) -> None

        Connect one of this node's attributes to an attribute on another node.
        This will immediately set the target attribute's value to that of the
        source attribute, and will continue to do so once per step as long as
        the two nodes exist.  The connection can be severed by setting the
        target attribute to any value or connecting another node attribute
        to it.

        # Example: create a locator and attach a light to it:
        light = ba.newnode('light')
        loc = ba.newnode('locator', attrs={'position': (0,10,0)})
        loc.connectattr('position', light, 'position')
        """
        return None

    def delete(self, ignore_missing: bool = True) -> None:
        """delete(ignore_missing: bool = True) -> None

        Delete the node.  Ignores already-deleted nodes if ignore_missing
        is True; otherwise a ba.NodeNotFoundError is thrown.
        """
        return None

    def exists(self) -> bool:
        """exists() -> bool

        Returns whether the Node still exists.
        Most functionality will fail on a nonexistent Node, so it's never a bad
        idea to check this.

        Note that you can also use the boolean operator for this same
        functionality, so a statement such as "if mynode" will do
        the right thing both for Node objects and values of None.
        """
        return bool()

    # Show that ur return type varies based on "doraise" value:
    @overload
    def getdelegate(self,
                    type: Type[_T],
                    doraise: Literal[False] = False) -> Optional[_T]:
        ...

    @overload
    def getdelegate(self, type: Type[_T], doraise: Literal[True]) -> _T:
        ...

    def getdelegate(self, type: Any, doraise: bool = False) -> Any:
        """getdelegate(type: Type, doraise: bool = False) -> <varies>

        Return the node's current delegate object if it matches a certain type.

        If the node has no delegate or it is not an instance of the passed
        type, then None will be returned. If 'doraise' is True, then an
        ba.DelegateNotFoundError will be raised instead.
        """
        return None

    def getname(self) -> str:
        """getname() -> str

        Return the name assigned to a Node; used mainly for debugging
        """
        return str()

    def getnodetype(self) -> str:
        """getnodetype() -> str

        Return the type of Node referenced by this object as a string.
        (Note this is different from the Python type which is always ba.Node)
        """
        return str()

    def handlemessage(self, *args: Any) -> None:
        """handlemessage(*args: Any) -> None

        General message handling; can be passed any message object.

        All standard message objects are forwarded along to the ba.Node's
        delegate for handling (generally the ba.Actor that made the node).

        ba.Nodes are unique, however, in that they can be passed a second
        form of message; 'node-messages'.  These consist of a string type-name
        as a first argument along with the args specific to that type name
        as additional arguments.
        Node-messages communicate directly with the low-level node layer
        and are delivered simultaneously on all game clients,
        acting as an alternative to setting node attributes.
        """
        return None


class SessionData:
    """(internal)"""

    def exists(self) -> bool:
        """exists() -> bool

        Returns whether the SessionData still exists.
        Most functionality will fail on a nonexistent instance.
        """
        return bool()


class SessionPlayer:
    """A reference to a player in the ba.Session.

    Category: Gameplay Classes

    These are created and managed internally and
    provided to your Session/Activity instances.
    Be aware that, like ba.Nodes, ba.SessionPlayer objects are 'weak'
    references under-the-hood; a player can leave the game at
     any point. For this reason, you should make judicious use of the
    ba.SessionPlayer.exists() method (or boolean operator) to ensure
    that a SessionPlayer is still present if retaining references to one
    for any length of time.

    Attributes:

        id: int
            The unique numeric ID of the Player.

            Note that you can also use the boolean operator for this same
            functionality, so a statement such as "if player" will do
            the right thing both for Player objects and values of None.

        in_game: bool
            This bool value will be True once the Player has completed
            any lobby character/team selection.

        sessionteam: ba.SessionTeam
            The ba.SessionTeam this Player is on. If the SessionPlayer
            is still in its lobby selecting a team/etc. then a
            ba.SessionTeamNotFoundError will be raised.

        inputdevice: ba.InputDevice
            The input device associated with the player.

        color: Sequence[float]
            The base color for this Player.
            In team games this will match the ba.SessionTeam's color.

        highlight: Sequence[float]
            A secondary color for this player.
            This is used for minor highlights and accents
            to allow a player to stand apart from his teammates
            who may all share the same team (primary) color.

        character: str
            The character this player has selected in their profile.

        activityplayer: Optional[ba.Player]
            The current game-specific instance for this player.
    """
    id: int
    in_game: bool
    sessionteam: ba.SessionTeam
    inputdevice: ba.InputDevice
    color: Sequence[float]
    highlight: Sequence[float]
    character: str
    activityplayer: Optional[ba.Player]

    def assigninput(self, type: Union[ba.InputType, Tuple[ba.InputType, ...]],
                    call: Callable) -> None:
        """assigninput(type: Union[ba.InputType, Tuple[ba.InputType, ...]],
          call: Callable) -> None

        Set the python callable to be run for one or more types of input.
        """
        return None

    def exists(self) -> bool:
        """exists() -> bool

        Return whether the underlying player is still in the game.
        """
        return bool()

    def get_account_id(self) -> str:
        """get_account_id() -> str

        Return the Account ID this player is signed in under, if
        there is one and it can be determined with relative certainty.
        Returns None otherwise. Note that this may require an active
        internet connection (especially for network-connected players)
        and may return None for a short while after a player initially
        joins (while verification occurs).
        """
        return str()

    def get_icon(self) -> Dict[str, Any]:
        """get_icon() -> Dict[str, Any]

        Returns the character's icon (images, colors, etc contained in a dict)
        """
        return {'foo': 'bar'}

    def get_icon_info(self) -> Dict[str, Any]:
        """get_icon_info() -> Dict[str, Any]

        (internal)
        """
        return {'foo': 'bar'}

    def getname(self, full: bool = False, icon: bool = True) -> str:
        """getname(full: bool = False, icon: bool = True) -> str

        Returns the player's name. If icon is True, the long version of the
        name may include an icon.
        """
        return str()

    def remove_from_game(self) -> None:
        """remove_from_game() -> None

        Removes the player from the game.
        """
        return None

    def resetinput(self) -> None:
        """resetinput() -> None

        Clears out the player's assigned input actions.
        """
        return None

    def set_icon_info(self, texture: str, tint_texture: str,
                      tint_color: Sequence[float],
                      tint2_color: Sequence[float]) -> None:
        """set_icon_info(texture: str, tint_texture: str,
          tint_color: Sequence[float], tint2_color: Sequence[float]) -> None

        (internal)
        """
        return None

    def setactivity(self, activity: Optional[ba.Activity]) -> None:
        """setactivity(activity: Optional[ba.Activity]) -> None

        (internal)
        """
        return None

    def setdata(self, team: ba.SessionTeam, character: str,
                color: Sequence[float], highlight: Sequence[float]) -> None:
        """setdata(team: ba.SessionTeam, character: str,
          color: Sequence[float], highlight: Sequence[float]) -> None

        (internal)
        """
        return None

    def setname(self,
                name: str,
                full_name: str = None,
                real: bool = True) -> None:
        """setname(name: str, full_name: str = None, real: bool = True)
          -> None

        Set the player's name to the provided string.
        A number will automatically be appended if the name is not unique from
        other players.
        """
        return None

    def setnode(self, node: Optional[Node]) -> None:
        """setnode(node: Optional[Node]) -> None

        (internal)
        """
        return None


class Sound:
    """A reference to a sound.

    Category: Asset Classes

    Use ba.getsound() to instantiate one.
    """
    pass


class Texture:
    """A reference to a texture.

    Category: Asset Classes

    Use ba.gettexture() to instantiate one.
    """
    pass


class Timer:
    """Timer(time: float, call: Callable[[], Any], repeat: bool = False,
      timetype: ba.TimeType = TimeType.SIM,
      timeformat: ba.TimeFormat = TimeFormat.SECONDS,
      suppress_format_warning: bool = False)

    Timers are used to run code at later points in time.

    Category: General Utility Classes

    This class encapsulates a timer in the current ba.Context.
    The underlying timer will be destroyed when either this object is
    no longer referenced or when its Context (Activity, etc.) dies. If you
    do not want to worry about keeping a reference to your timer around,
    you should use the ba.timer() function instead.

    time: length of time (in seconds by default) that the timer will wait
    before firing. Note that the actual delay experienced may vary
     depending on the timetype. (see below)

    call: A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as ba.WeakCall if that is not
    desired.

    repeat: if True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    timetype can be either 'sim', 'base', or 'real'. It defaults to
    'sim'. Types are explained below:

    'sim' time maps to local simulation time in ba.Activity or ba.Session
    Contexts. This means that it may progress slower in slow-motion play
    modes, stop when the game is paused, etc.  This time type is not
    available in UI contexts.

    'base' time is also linked to gameplay in ba.Activity or ba.Session
    Contexts, but it progresses at a constant rate regardless of
     slow-motion states or pausing.  It can, however, slow down or stop
    in certain cases such as network outages or game slowdowns due to
    cpu load. Like 'sim' time, this is unavailable in UI contexts.

    'real' time always maps to actual clock time with a bit of filtering
    added, regardless of Context.  (the filtering prevents it from going
    backwards or jumping forward by large amounts due to the app being
    backgrounded, system time changing, etc.)
    Real time timers are currently only available in the UI context.

    the 'timeformat' arg defaults to SECONDS but can also be MILLISECONDS
    if you want to pass time as milliseconds.

    # Example: use a Timer object to print repeatedly for a few seconds:
    def say_it():
        ba.screenmessage('BADGER!')
    def stop_saying_it():
        self.t = None
        ba.screenmessage('MUSHROOM MUSHROOM!')
    # create our timer; it will run as long as we hold self.t
    self.t = ba.Timer(0.3, say_it, repeat=True)
    # now fire off a one-shot timer to kill it
    ba.timer(3.89, stop_saying_it)
    """

    def __init__(self,
                 time: float,
                 call: Callable[[], Any],
                 repeat: bool = False,
                 timetype: ba.TimeType = TimeType.SIM,
                 timeformat: ba.TimeFormat = TimeFormat.SECONDS,
                 suppress_format_warning: bool = False):
        pass


class Vec3(Sequence[float]):
    """A vector of 3 floats.

    Category: General Utility Classes

    These can be created the following ways (checked in this order):
    - with no args, all values are set to 0
    - with a single numeric arg, all values are set to that value
    - with a single three-member sequence arg, sequence values are copied
    - otherwise assumes individual x/y/z args (positional or keywords)
    Attributes:

       x: float
          The vector's X component.

       y: float
          The vector's Y component.

       z: float
          The vector's Z component.
    """
    x: float
    y: float
    z: float

    # pylint: disable=function-redefined

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, value: float):
        pass

    @overload
    def __init__(self, values: Sequence[float]):
        pass

    @overload
    def __init__(self, x: float, y: float, z: float):
        pass

    def __init__(self, *args: Any, **kwds: Any):
        pass

    def __add__(self, other: Vec3) -> Vec3:
        return self

    def __sub__(self, other: Vec3) -> Vec3:
        return self

    @overload
    def __mul__(self, other: float) -> Vec3:
        return self

    @overload
    def __mul__(self, other: Sequence[float]) -> Vec3:
        return self

    def __mul__(self, other: Any) -> Any:
        return self

    @overload
    def __rmul__(self, other: float) -> Vec3:
        return self

    @overload
    def __rmul__(self, other: Sequence[float]) -> Vec3:
        return self

    def __rmul__(self, other: Any) -> Any:
        return self

    # (for index access)
    def __getitem__(self, typeargs: Any) -> Any:
        return 0.0

    def __len__(self) -> int:
        return 3

    # (for iterator access)
    def __iter__(self) -> Any:
        return self

    def __next__(self) -> float:
        return 0.0

    def __neg__(self) -> Vec3:
        return self

    def __setitem__(self, index: int, val: float) -> None:
        pass

    def cross(self, other: Vec3) -> Vec3:
        """cross(other: Vec3) -> Vec3

        Returns the cross product of this vector and another.
        """
        return Vec3()

    def dot(self, other: Vec3) -> float:
        """dot(other: Vec3) -> float

        Returns the dot product of this vector and another.
        """
        return float()

    def length(self) -> float:
        """length() -> float

        Returns the length of the vector.
        """
        return float()

    def normalized(self) -> Vec3:
        """normalized() -> Vec3

        Returns a normalized version of the vector.
        """
        return Vec3()


class Widget:
    """Internal type for low level UI elements; buttons, windows, etc.

    Category: User Interface Classes

    This class represents a weak reference to a widget object
    in the internal c++ layer. Currently, functions such as
    ba.buttonwidget() must be used to instantiate or edit these.
    """

    def activate(self) -> None:
        """activate() -> None

        Activates a widget; the same as if it had been clicked.
        """
        return None

    def add_delete_callback(self, call: Callable) -> None:
        """add_delete_callback(call: Callable) -> None

        Add a call to be run immediately after this widget is destroyed.
        """
        return None

    def delete(self, ignore_missing: bool = True) -> None:
        """delete(ignore_missing: bool = True) -> None

        Delete the Widget.  Ignores already-deleted Widgets if ignore_missing
          is True; otherwise an Exception is thrown.
        """
        return None

    def exists(self) -> bool:
        """exists() -> bool

        Returns whether the Widget still exists.
        Most functionality will fail on a nonexistent widget.

        Note that you can also use the boolean operator for this same
        functionality, so a statement such as "if mywidget" will do
        the right thing both for Widget objects and values of None.
        """
        return bool()

    def get_children(self) -> List[ba.Widget]:
        """get_children() -> List[ba.Widget]

        Returns any child Widgets of this Widget.
        """
        return [Widget()]

    def get_screen_space_center(self) -> Tuple[float, float]:
        """get_screen_space_center() -> Tuple[float, float]

        Returns the coords of the Widget center relative to the center of the
        screen. This can be useful for placing pop-up windows and other special
        cases.
        """
        return (0.0, 0.0)

    def get_selected_child(self) -> Optional[ba.Widget]:
        """get_selected_child() -> Optional[ba.Widget]

        Returns the selected child Widget or None if nothing is selected.
        """
        return Widget()

    def get_widget_type(self) -> str:
        """get_widget_type() -> str

        Return the internal type of the Widget as a string.  Note that this is
        different from the Python ba.Widget type, which is the same for all
        widgets.
        """
        return str()


def _app() -> ba.App:
    """_app() -> ba.App

    (internal)
    """
    import ba  # pylint: disable=cyclic-import
    return ba.App()


def accept_party_invitation(invite_id: str) -> None:
    """accept_party_invitation(invite_id: str) -> None

    (internal)
    """
    return None


def add_clean_frame_callback(call: Callable) -> None:
    """add_clean_frame_callback(call: Callable) -> None

    (internal)

    Provide an object to be called once the next non-progress-bar-frame has
    been rendered. Useful for queueing things to load in the background
    without elongating any current progress-bar-load.
    """
    return None


def add_transaction(transaction: dict, callback: Callable = None) -> None:
    """add_transaction(transaction: dict, callback: Callable = None) -> None

    (internal)
    """
    return None


def android_get_external_storage_path() -> str:
    """android_get_external_storage_path() -> str

    (internal)

    Returns the android external storage path, or None if there is none on
    this device
    """
    return str()


def android_media_scan_file(file_name: str) -> None:
    """android_media_scan_file(file_name: str) -> None

    (internal)

    Refreshes Android MTP Index for a file; use this to get file
    modifications to be reflected in Android File Transfer.
    """
    return None


def android_show_wifi_settings() -> None:
    """android_show_wifi_settings() -> None

    (internal)
    """
    return None


def apply_config() -> None:
    """apply_config() -> None

    (internal)
    """
    return None


def appname() -> str:
    """appname() -> str

    (internal)
    """
    return str()


def appnameupper() -> str:
    """appnameupper() -> str

    (internal)
    """
    return str()


def back_press() -> None:
    """back_press() -> None

    (internal)
    """
    return None


def bless() -> None:
    """bless() -> None

    (internal)
    """
    return None


def buttonwidget(edit: ba.Widget = None,
                 parent: ba.Widget = None,
                 size: Sequence[float] = None,
                 position: Sequence[float] = None,
                 on_activate_call: Callable = None,
                 label: Union[str, ba.Lstr] = None,
                 color: Sequence[float] = None,
                 down_widget: ba.Widget = None,
                 up_widget: ba.Widget = None,
                 left_widget: ba.Widget = None,
                 right_widget: ba.Widget = None,
                 texture: ba.Texture = None,
                 text_scale: float = None,
                 textcolor: Sequence[float] = None,
                 enable_sound: bool = None,
                 model_transparent: ba.Model = None,
                 model_opaque: ba.Model = None,
                 repeat: bool = None,
                 scale: float = None,
                 transition_delay: float = None,
                 on_select_call: Callable = None,
                 button_type: str = None,
                 extra_touch_border_scale: float = None,
                 selectable: bool = None,
                 show_buffer_top: float = None,
                 icon: ba.Texture = None,
                 iconscale: float = None,
                 icon_tint: float = None,
                 icon_color: Sequence[float] = None,
                 autoselect: bool = None,
                 mask_texture: ba.Texture = None,
                 tint_texture: ba.Texture = None,
                 tint_color: Sequence[float] = None,
                 tint2_color: Sequence[float] = None,
                 text_flatness: float = None,
                 text_res_scale: float = None,
                 enabled: bool = None) -> ba.Widget:
    """buttonwidget(edit: ba.Widget = None,
      parent: ba.Widget = None,
      size: Sequence[float] = None,
      position: Sequence[float] = None,
      on_activate_call: Callable = None,
      label: Union[str, ba.Lstr] = None,
      color: Sequence[float] = None,
      down_widget: ba.Widget = None,
      up_widget: ba.Widget = None,
      left_widget: ba.Widget = None,
      right_widget: ba.Widget = None,
      texture: ba.Texture = None,
      text_scale: float = None,
      textcolor: Sequence[float] = None,
      enable_sound: bool = None,
      model_transparent: ba.Model = None,
      model_opaque: ba.Model = None,
      repeat: bool = None,
      scale: float = None,
      transition_delay: float = None,
      on_select_call: Callable = None,
      button_type: str = None,
      extra_touch_border_scale: float = None,
      selectable: bool = None,
      show_buffer_top: float = None,
      icon: ba.Texture = None,
      iconscale: float = None,
      icon_tint: float = None,
      icon_color: Sequence[float] = None,
      autoselect: bool = None,
      mask_texture: ba.Texture = None,
      tint_texture: ba.Texture = None,
      tint_color: Sequence[float] = None,
      tint2_color: Sequence[float] = None,
      text_flatness: float = None,
      text_res_scale: float = None,
      enabled: bool = None) -> ba.Widget

    Create or edit a button widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def camerashake(intensity: float = 1.0) -> None:
    """camerashake(intensity: float = 1.0) -> None

    Shake the camera.

    Category: Gameplay Functions

    Note that some cameras and/or platforms (such as VR) may not display
    camera-shake, so do not rely on this always being visible to the
    player as a gameplay cue.
    """
    return None


def can_show_ad() -> bool:
    """can_show_ad() -> bool

    (internal)
    """
    return bool()


def capture_gamepad_input(call: Callable[[dict], None]) -> None:
    """capture_gamepad_input(call: Callable[[dict], None]) -> None

    (internal)

    Add a callable to be called for subsequent gamepad events.
    The method is passed a dict containing info about the event.
    """
    return None


def capture_keyboard_input(call: Callable[[dict], None]) -> None:
    """capture_keyboard_input(call: Callable[[dict], None]) -> None

    (internal)

    Add a callable to be called for subsequent keyboard-game-pad events.
    The method is passed a dict containing info about the event.
    """
    return None


def charstr(char_id: ba.SpecialChar) -> str:
    """charstr(char_id: ba.SpecialChar) -> str

    Get a unicode string representing a special character.

    Category: General Utility Functions

    Note that these utilize the private-use block of unicode characters
    (U+E000-U+F8FF) and are specific to the game; exporting or rendering
    them elsewhere will be meaningless.

    see ba.SpecialChar for the list of available characters.
    """
    return str()


def chatmessage(message: Union[str, ba.Lstr],
                clients: Sequence[int] = None,
                sender_override: str = None) -> None:
    """chatmessage(message: Union[str, ba.Lstr],
      clients: Sequence[int] = None,
      sender_override: str = None) -> None

    (internal)
    """
    return None


def checkboxwidget(edit: ba.Widget = None,
                   parent: ba.Widget = None,
                   size: Sequence[float] = None,
                   position: Sequence[float] = None,
                   text: Union[ba.Lstr, str] = None,
                   value: bool = None,
                   on_value_change_call: Callable[[bool], None] = None,
                   on_select_call: Callable[[], None] = None,
                   text_scale: float = None,
                   textcolor: Sequence[float] = None,
                   scale: float = None,
                   is_radio_button: bool = None,
                   maxwidth: float = None,
                   autoselect: bool = None,
                   color: Sequence[float] = None) -> ba.Widget:
    """checkboxwidget(edit: ba.Widget = None,
      parent: ba.Widget = None,
      size: Sequence[float] = None,
      position: Sequence[float] = None,
      text: Union[ba.Lstr, str] = None,
      value: bool = None,
      on_value_change_call: Callable[[bool], None] = None,
      on_select_call: Callable[[], None] = None,
      text_scale: float = None,
      textcolor: Sequence[float] = None,
      scale: float = None,
      is_radio_button: bool = None,
      maxwidth: float = None,
      autoselect: bool = None,
      color: Sequence[float] = None) -> ba.Widget

    Create or edit a check-box widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def client_info_query_response(token: str, response: Any) -> None:
    """client_info_query_response(token: str, response: Any) -> None

    (internal)
    """
    return None


def columnwidget(edit: ba.Widget = None,
                 parent: ba.Widget = None,
                 size: Sequence[float] = None,
                 position: Sequence[float] = None,
                 background: bool = None,
                 selected_child: ba.Widget = None,
                 visible_child: ba.Widget = None,
                 single_depth: bool = None,
                 print_list_exit_instructions: bool = None,
                 left_border: float = None,
                 top_border: float = None,
                 bottom_border: float = None) -> ba.Widget:
    """columnwidget(edit: ba.Widget = None,
      parent: ba.Widget = None,
      size: Sequence[float] = None,
      position: Sequence[float] = None,
      background: bool = None,
      selected_child: ba.Widget = None,
      visible_child: ba.Widget = None,
      single_depth: bool = None,
      print_list_exit_instructions: bool = None,
      left_border: float = None,
      top_border: float = None,
      bottom_border: float = None) -> ba.Widget

    Create or edit a column widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def commit_config(config: str) -> None:
    """commit_config(config: str) -> None

    (internal)
    """
    return None


def connect_to_party(address: str,
                     port: int = None,
                     print_progress: bool = True) -> None:
    """connect_to_party(address: str, port: int = None,
      print_progress: bool = True) -> None

    (internal)
    """
    return None


def console_print(*args: Any) -> None:
    """console_print(*args: Any) -> None

    (internal)

    Print the provided args to the game console (using str()).
    For most debugging/info purposes you should just use Python's standard
    print, which will show up in the game console as well.
    """
    return None


def containerwidget(edit: ba.Widget = None,
                    parent: ba.Widget = None,
                    size: Sequence[float] = None,
                    position: Sequence[float] = None,
                    background: bool = None,
                    selected_child: ba.Widget = None,
                    transition: str = None,
                    cancel_button: ba.Widget = None,
                    start_button: ba.Widget = None,
                    root_selectable: bool = None,
                    on_activate_call: Callable[[], None] = None,
                    claims_left_right: bool = None,
                    claims_tab: bool = None,
                    selection_loops: bool = None,
                    selection_loop_to_parent: bool = None,
                    scale: float = None,
                    on_outside_click_call: Callable[[], None] = None,
                    single_depth: bool = None,
                    visible_child: ba.Widget = None,
                    stack_offset: Sequence[float] = None,
                    color: Sequence[float] = None,
                    on_cancel_call: Callable[[], None] = None,
                    print_list_exit_instructions: bool = None,
                    click_activate: bool = None,
                    always_highlight: bool = None,
                    selectable: bool = None,
                    scale_origin_stack_offset: Sequence[float] = None,
                    toolbar_visibility: str = None,
                    on_select_call: Callable[[], None] = None,
                    claim_outside_clicks: bool = None,
                    claims_up_down: bool = None) -> ba.Widget:
    """containerwidget(edit: ba.Widget = None,
      parent: ba.Widget = None,
      size: Sequence[float] = None,
      position: Sequence[float] = None,
      background: bool = None,
      selected_child: ba.Widget = None,
      transition: str = None,
      cancel_button: ba.Widget = None,
      start_button: ba.Widget = None,
      root_selectable: bool = None,
      on_activate_call: Callable[[], None] = None,
      claims_left_right: bool = None,
      claims_tab: bool = None,
      selection_loops: bool = None,
      selection_loop_to_parent: bool = None,
      scale: float = None,
      on_outside_click_call: Callable[[], None] = None,
      single_depth: bool = None,
      visible_child: ba.Widget = None,
      stack_offset: Sequence[float] = None,
      color: Sequence[float] = None,
      on_cancel_call: Callable[[], None] = None,
      print_list_exit_instructions: bool = None,
      click_activate: bool = None,
      always_highlight: bool = None,
      selectable: bool = None,
      scale_origin_stack_offset: Sequence[float] = None,
      toolbar_visibility: str = None,
      on_select_call: Callable[[], None] = None,
      claim_outside_clicks: bool = None,
      claims_up_down: bool = None) -> ba.Widget

    Create or edit a container widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def debug_print_py_err() -> None:
    """debug_print_py_err() -> None

    (internal)

    Debugging func for tracking leaked Python errors in the C++ layer..
    """
    return None


def disconnect_client(client_id: int, ban_time: int = 300) -> bool:
    """disconnect_client(client_id: int, ban_time: int = 300) -> bool

    (internal)
    """
    return bool()


def disconnect_from_host() -> None:
    """disconnect_from_host() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def do_once() -> bool:
    """do_once() -> bool

    Register a call at a location and return whether one already happened.

    Category: General Utility Functions

    This is used by 'print_once()' type calls to keep from overflowing
    logs. The call functions by registering the filename and line where
    The call is made from.  Returns True if this location has not been
    registered already, and False if it has.

    # Example: this print will only fire for the first loop iteration:
    for i in range(10):
        if ba.do_once():
            print('Hello once from loop!')
    """
    return bool()


def ehv() -> None:
    """ehv() -> None

    (internal)
    """
    return None


def emitfx(position: Sequence[float],
           velocity: Optional[Sequence[float]] = None,
           count: int = 10,
           scale: float = 1.0,
           spread: float = 1.0,
           chunk_type: str = 'rock',
           emit_type: str = 'chunks',
           tendril_type: str = 'smoke') -> None:
    """emitfx(position: Sequence[float],
      velocity: Optional[Sequence[float]] = None,
      count: int = 10, scale: float = 1.0, spread: float = 1.0,
      chunk_type: str = 'rock', emit_type: str ='chunks',
      tendril_type: str = 'smoke') -> None

    Emit particles, smoke, etc. into the fx sim layer.

    Category: Gameplay Functions

    The fx sim layer is a secondary dynamics simulation that runs in
    the background and just looks pretty; it does not affect gameplay.
    Note that the actual amount emitted may vary depending on graphics
    settings, exiting element counts, or other factors.
    """
    return None


def end_host_scanning() -> None:
    """end_host_scanning() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def env() -> dict:
    """env() -> dict

    (internal)

    Returns a dict containing general info about the operating environment
    such as version, platform, etc.
    This info is now exposed through ba.App; refer to those docs for
    info on specific elements.
    """
    return dict()


def evaluate_lstr(value: str) -> str:
    """evaluate_lstr(value: str) -> str

    (internal)
    """
    return str()


def fade_screen(to: int = 0,
                time: float = 0.25,
                endcall: Optional[Callable[[], None]] = None) -> None:
    """fade_screen(to: int = 0, time: float = 0.25,
      endcall: Optional[Callable[[], None]] = None) -> None

    (internal)

    Fade the local game screen in our out from black over a duration of
    time. if "to" is 0, the screen will fade out to black.  Otherwise it
    will fade in from black. If endcall is provided, it will be run after a
    completely faded frame is drawn.
    """
    return None


def focus_window() -> None:
    """focus_window() -> None

    (internal)

    A workaround for some unintentional backgrounding that occurs on mac
    """
    return None


def game_service_has_leaderboard(game: str, config: str) -> bool:
    """game_service_has_leaderboard(game: str, config: str) -> bool

    (internal)

    Given a game and config string, returns whether there is a leaderboard
    for it on the game service.
    """
    return bool()


def get_account_display_string(full: bool = True) -> str:
    """get_account_display_string(full: bool = True) -> str

    (internal)
    """
    return str()


def get_account_misc_read_val(name: str, default_value: Any) -> Any:
    """get_account_misc_read_val(name: str, default_value: Any) -> Any

    (internal)
    """
    return _uninferrable()


def get_account_misc_read_val_2(name: str, default_value: Any) -> Any:
    """get_account_misc_read_val_2(name: str, default_value: Any) -> Any

    (internal)
    """
    return _uninferrable()


def get_account_misc_val(name: str, default_value: Any) -> Any:
    """get_account_misc_val(name: str, default_value: Any) -> Any

    (internal)
    """
    return _uninferrable()


def get_account_name() -> str:
    """get_account_name() -> str

    (internal)
    """
    return str()


def get_account_state() -> str:
    """get_account_state() -> str

    (internal)
    """
    return str()


def get_account_state_num() -> int:
    """get_account_state_num() -> int

    (internal)
    """
    return int()


def get_account_ticket_count() -> int:
    """get_account_ticket_count() -> int

    (internal)

    Returns the number of tickets for the current account.
    """
    return int()


def get_account_type() -> str:
    """get_account_type() -> str

    (internal)
    """
    return str()


def get_appconfig_builtin_keys() -> List[str]:
    """get_appconfig_builtin_keys() -> List[str]

    (internal)
    """
    return ['blah', 'blah2']


def get_appconfig_default_value(key: str) -> Any:
    """get_appconfig_default_value(key: str) -> Any

    (internal)
    """
    return _uninferrable()


def get_chat_messages() -> List[str]:
    """get_chat_messages() -> List[str]

    (internal)
    """
    return ['blah', 'blah2']


def get_collision_info(*args: Any) -> Any:
    """get_collision_info(*args: Any) -> Any

    Return collision related values

    Category: Gameplay Functions

    Returns a single collision value or tuple of values such as location,
    depth, nodes involved, etc. Only call this in the handler of a
    collision-triggered callback or message
    """
    return _uninferrable()


def get_configurable_game_pads() -> list:
    """get_configurable_game_pads() -> list

    (internal)

    Returns a list of the currently connected gamepads that can be
    configured.
    """
    return list()


def get_connection_to_host_info() -> dict:
    """get_connection_to_host_info() -> dict

    (internal)
    """
    return dict()


def get_display_resolution() -> Optional[Tuple[int, int]]:
    """get_display_resolution() -> Optional[Tuple[int, int]]

    (internal)

    Return the currently selected display resolution for fullscreen
    display. Returns None if resolutions cannot be directly set.
    """
    return (0, 0)


def get_foreground_host_activity() -> Optional[ba.Activity]:
    """get_foreground_host_activity() -> Optional[ba.Activity]

    (internal)

    Returns the ba.Activity currently in the foreground, or None if there
    is none.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Activity(settings={})


def get_foreground_host_session() -> Optional[ba.Session]:
    """get_foreground_host_session() -> Optional[ba.Session]

    (internal)

    Return the ba.Session currently being displayed, or None if there is
    none.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Session([])


def get_game_port() -> int:
    """get_game_port() -> int

    (internal)

    Return the port ballistica is hosting on.
    """
    return int()


def get_game_roster() -> List[Dict[str, Any]]:
    """get_game_roster() -> List[Dict[str, Any]]

    (internal)
    """
    return [{'foo': 'bar'}]


def get_google_play_party_client_count() -> int:
    """get_google_play_party_client_count() -> int

    (internal)
    """
    return int()


def get_idle_time() -> int:
    """get_idle_time() -> int

    (internal)

    Returns the amount of time since any game input has been processed
    """
    return int()


def get_local_active_input_devices_count() -> int:
    """get_local_active_input_devices_count() -> int

    (internal)
    """
    return int()


def get_log_file_path() -> str:
    """get_log_file_path() -> str

    (internal)

    Return the path to the app log file.
    """
    return str()


def get_low_level_config_value(key: str, default_value: int) -> int:
    """get_low_level_config_value(key: str, default_value: int) -> int

    (internal)
    """
    return int()


def get_master_server_address(source: int = -1) -> str:
    """get_master_server_address(source: int = -1) -> str

    (internal)

    Return the address of the master server.
    """
    return str()


def get_max_graphics_quality() -> str:
    """get_max_graphics_quality() -> str

    (internal)

    Return the max graphics-quality supported on the current hardware.
    """
    return str()


def get_news_show() -> str:
    """get_news_show() -> str

    (internal)
    """
    return str()


def get_package_collide_model(package: ba.AssetPackage,
                              name: str) -> ba.CollideModel:
    """get_package_collide_model(package: ba.AssetPackage, name: str)
    -> ba.CollideModel

    (internal)
    """
    import ba  # pylint: disable=cyclic-import
    return ba.CollideModel()


def get_package_data(package: ba.AssetPackage, name: str) -> ba.Data:
    """get_package_data(package: ba.AssetPackage, name: str) -> ba.Data

    (internal).
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Data()


def get_package_model(package: ba.AssetPackage, name: str) -> ba.Model:
    """get_package_model(package: ba.AssetPackage, name: str) -> ba.Model

    (internal)
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Model()


def get_package_sound(package: ba.AssetPackage, name: str) -> ba.Sound:
    """get_package_sound(package: ba.AssetPackage, name: str) -> ba.Sound

    (internal).
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Sound()


def get_package_texture(package: ba.AssetPackage, name: str) -> ba.Texture:
    """get_package_texture(package: ba.AssetPackage, name: str) -> ba.Texture

    (internal)
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Texture()


def get_price(item: str) -> Optional[str]:
    """get_price(item: str) -> Optional[str]

    (internal)
    """
    return ''


def get_public_login_id() -> Optional[str]:
    """get_public_login_id() -> Optional[str]

    (internal)
    """
    return ''


def get_public_party_enabled() -> bool:
    """get_public_party_enabled() -> bool

    (internal)
    """
    return bool()


def get_public_party_max_size() -> int:
    """get_public_party_max_size() -> int

    (internal)
    """
    return int()


def get_purchased(item: str) -> bool:
    """get_purchased(item: str) -> bool

    (internal)
    """
    return bool()


def get_purchases_state() -> int:
    """get_purchases_state() -> int

    (internal)
    """
    return int()


def get_qrcode_texture(url: str) -> ba.Texture:
    """get_qrcode_texture(url: str) -> ba.Texture

    (internal)
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Texture()


def get_random_names() -> list:
    """get_random_names() -> list

    (internal)

    Returns the random names used by the game.
    """
    return list()


def get_replay_speed_exponent() -> int:
    """get_replay_speed_exponent() -> int

    (internal)

    Returns current replay speed value. Actual displayed speed is pow(2,speed).
    """
    return int()


def get_replays_dir() -> str:
    """get_replays_dir() -> str

    (internal)
    """
    return str()


def get_scores_to_beat(level: str, config: str, callback: Callable) -> None:
    """get_scores_to_beat(level: str, config: str, callback: Callable) -> None

    (internal)
    """
    return None


def get_special_widget(name: str) -> Widget:
    """get_special_widget(name: str) -> Widget

    (internal)
    """
    return Widget()


def get_string_height(string: str, suppress_warning: bool = False) -> float:
    """get_string_height(string: str, suppress_warning: bool = False) -> float

    (internal)

    Given a string, returns its height using the standard small app
    font.
    """
    return float()


def get_string_width(string: str, suppress_warning: bool = False) -> float:
    """get_string_width(string: str, suppress_warning: bool = False) -> float

    (internal)

    Given a string, returns its width using the standard small app
    font.
    """
    return float()


def get_thread_name() -> str:
    """get_thread_name() -> str

    (internal)

    Returns the name of the current thread.
    This may vary depending on platform and should not be used in logic;
    only for debugging.
    """
    return str()


def get_ui_input_device() -> ba.InputDevice:
    """get_ui_input_device() -> ba.InputDevice

    (internal)

    Returns the input-device that currently owns the user interface, or
    None if there is none.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.InputDevice()


# Show that our return type varies based on "doraise" value:
@overload
def getactivity(doraise: Literal[True] = True) -> ba.Activity:
    ...


@overload
def getactivity(doraise: Literal[False]) -> Optional[ba.Activity]:
    ...


def getactivity(doraise: bool = True) -> Optional[ba.Activity]:
    """getactivity(doraise: bool = True) -> <varies>

    Return the current ba.Activity instance.

    Category: Gameplay Functions

    Note that this is based on context; thus code run in a timer generated
    in Activity 'foo' will properly return 'foo' here, even if another
    Activity has since been created or is transitioning in.
    If there is no current Activity, raises a ba.ActivityNotFoundError.
    If doraise is False, None will be returned instead in that case.
    """
    return None


def getcollidemodel(name: str) -> ba.CollideModel:
    """getcollidemodel(name: str) -> ba.CollideModel

    Return a collide-model, loading it if necessary.

    Category: Asset Functions

    Collide-models are used in physics calculations for such things as
    terrain.

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.CollideModel()


def getdata(name: str) -> ba.Data:
    """getdata(name: str) -> ba.Data

    Return a data, loading it if necessary.

    Category: Asset Functions

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Data()


# Show that our return type varies based on "doraise" value:
@overload
def getinputdevice(name: str,
                   unique_id: str,
                   doraise: Literal[True] = True) -> ba.InputDevice:
    ...


@overload
def getinputdevice(name: str, unique_id: str,
                   doraise: Literal[False]) -> Optional[ba.InputDevice]:
    ...


def getinputdevice(name: str, unique_id: str, doraise: bool = True) -> Any:
    """getinputdevice(name: str, unique_id: str, doraise: bool = True)
      -> <varies>

    (internal)

    Given a type name and a unique identifier, returns an InputDevice.
    Throws an Exception if the input-device is not found, or returns None
    if 'doraise' is False.
    """
    return None


def getlog() -> str:
    """getlog() -> str

    (internal)
    """
    return str()


def getmodel(name: str) -> ba.Model:
    """getmodel(name: str) -> ba.Model

    Return a model, loading it if necessary.

    Category: Asset Functions

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Model()


def getnodes() -> list:
    """getnodes() -> list

    Return all nodes in the current ba.Context.
    Category: Gameplay Functions
    """
    return list()


# Show that our return type varies based on "doraise" value:
@overload
def getsession(doraise: Literal[True] = True) -> ba.Session:
    ...


@overload
def getsession(doraise: Literal[False]) -> Optional[ba.Session]:
    ...


def getsession(doraise: bool = True) -> Optional[ba.Session]:
    """getsession(doraise: bool = True) -> <varies>

    Category: Gameplay Functions

    Returns the current ba.Session instance.
    Note that this is based on context; thus code being run in the UI
    context will return the UI context here even if a game Session also
    exists, etc. If there is no current Session, an Exception is raised, or
    if doraise is False then None is returned instead.
    """
    return None


def getsound(name: str) -> ba.Sound:
    """getsound(name: str) -> ba.Sound

    Return a sound, loading it if necessary.

    Category: Asset Functions

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Sound()


def gettexture(name: str) -> ba.Texture:
    """gettexture(name: str) -> ba.Texture

    Return a texture, loading it if necessary.

    Category: Asset Functions

    Note that this function returns immediately even if the media has yet
    to be loaded. To avoid hitches, instantiate your media objects in
    advance of when you will be using them, allowing time for them to load
    in the background if necessary.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Texture()


def has_gamma_control() -> bool:
    """has_gamma_control() -> bool

    (internal)

    Returns whether the system can adjust overall screen gamma)
    """
    return bool()


def has_user_mods() -> bool:
    """has_user_mods() -> bool

    (internal)

    Returns whether the system varies from default configuration
    (by user mods, etc)
    """
    return bool()


def has_user_run_commands() -> bool:
    """has_user_run_commands() -> bool

    (internal)
    """
    return bool()


def has_video_ads() -> bool:
    """has_video_ads() -> bool

    (internal)
    """
    return bool()


def have_chars(text: str) -> bool:
    """have_chars(text: str) -> bool

    (internal)
    """
    return bool()


def have_connected_clients() -> bool:
    """have_connected_clients() -> bool

    (internal)

    Category: General Utility Functions
    """
    return bool()


def have_incentivized_ad() -> bool:
    """have_incentivized_ad() -> bool

    (internal)
    """
    return bool()


def have_outstanding_transactions() -> bool:
    """have_outstanding_transactions() -> bool

    (internal)
    """
    return bool()


def have_permission(permission: ba.Permission) -> bool:
    """have_permission(permission: ba.Permission) -> bool

    (internal)
    """
    return bool()


def have_touchscreen_input() -> bool:
    """have_touchscreen_input() -> bool

    (internal)

    Returns whether or not a touch-screen input is present
    """
    return bool()


def host_scan_cycle() -> list:
    """host_scan_cycle() -> list

    (internal)
    """
    return list()


def hscrollwidget(edit: ba.Widget = None,
                  parent: ba.Widget = None,
                  size: Sequence[float] = None,
                  position: Sequence[float] = None,
                  background: bool = None,
                  selected_child: ba.Widget = None,
                  capture_arrows: bool = None,
                  on_select_call: Callable[[], None] = None,
                  center_small_content: bool = None,
                  color: Sequence[float] = None,
                  highlight: bool = None,
                  border_opacity: float = None,
                  simple_culling_h: float = None) -> ba.Widget:
    """hscrollwidget(edit: ba.Widget = None, parent: ba.Widget = None,
      size: Sequence[float] = None, position: Sequence[float] = None,
      background: bool = None, selected_child: ba.Widget = None,
      capture_arrows: bool = None,
      on_select_call: Callable[[], None] = None,
      center_small_content: bool = None, color: Sequence[float] = None,
      highlight: bool = None, border_opacity: float = None,
      simple_culling_h: float = None)  -> ba.Widget

    Create or edit a horizontal scroll widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def imagewidget(edit: ba.Widget = None,
                parent: ba.Widget = None,
                size: Sequence[float] = None,
                position: Sequence[float] = None,
                color: Sequence[float] = None,
                texture: ba.Texture = None,
                opacity: float = None,
                model_transparent: ba.Model = None,
                model_opaque: ba.Model = None,
                has_alpha_channel: bool = True,
                tint_texture: ba.Texture = None,
                tint_color: Sequence[float] = None,
                transition_delay: float = None,
                draw_controller: ba.Widget = None,
                tint2_color: Sequence[float] = None,
                tilt_scale: float = None,
                mask_texture: ba.Texture = None,
                radial_amount: float = None) -> ba.Widget:
    """imagewidget(edit: ba.Widget = None, parent: ba.Widget = None,
      size: Sequence[float] = None, position: Sequence[float] = None,
      color: Sequence[float] = None, texture: ba.Texture = None,
      opacity: float = None, model_transparent: ba.Model = None,
      model_opaque: ba.Model = None, has_alpha_channel: bool = True,
      tint_texture: ba.Texture = None, tint_color: Sequence[float] = None,
      transition_delay: float = None, draw_controller: ba.Widget = None,
      tint2_color: Sequence[float] = None, tilt_scale: float = None,
      mask_texture: ba.Texture = None, radial_amount: float = None)
      -> ba.Widget

    Create or edit an image widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def in_game_purchase(item: str, price: int) -> None:
    """in_game_purchase(item: str, price: int) -> None

    (internal)
    """
    return None


def in_game_thread() -> bool:
    """in_game_thread() -> bool

    (internal)

    Returns whether or not the current thread is the game thread.
    """
    return bool()


def increment_analytics_count(name: str, increment: int = 1) -> None:
    """increment_analytics_count(name: str, increment: int = 1) -> None

    (internal)
    """
    return None


def increment_analytics_count_raw_2(name: str,
                                    uses_increment: bool = True,
                                    increment: int = 1) -> None:
    """increment_analytics_count_raw_2(name: str,
      uses_increment: bool = True, increment: int = 1) -> None

    (internal)
    """
    return None


def increment_analytics_counts_raw(name: str, increment: int = 1) -> None:
    """increment_analytics_counts_raw(name: str, increment: int = 1) -> None

    (internal)
    """
    return None


def invite_players() -> None:
    """invite_players() -> None

    (internal)
    Category: General Utility Functions
    """
    return None


def is_blessed() -> bool:
    """is_blessed() -> bool

    (internal)
    """
    return bool()


def is_in_replay() -> bool:
    """is_in_replay() -> bool

    (internal)
    """
    return bool()


def is_log_full() -> bool:
    """is_log_full() -> bool

    (internal)
    """
    return bool()


def is_os_playing_music() -> bool:
    """is_os_playing_music() -> bool

    (internal)

    Tells whether the OS is currently playing music of some sort.

    (Used to determine whether the game should avoid playing its own)
    """
    return bool()


def is_ouya_build() -> bool:
    """is_ouya_build() -> bool

    (internal)

    Returns whether we're running the ouya-specific version
    """
    return bool()


def is_party_icon_visible() -> bool:
    """is_party_icon_visible() -> bool

    (internal)
    """
    return bool()


def is_running_on_fire_tv() -> bool:
    """is_running_on_fire_tv() -> bool

    (internal)
    """
    return bool()


def is_running_on_ouya() -> bool:
    """is_running_on_ouya() -> bool

    (internal)
    """
    return bool()


def lock_all_input() -> None:
    """lock_all_input() -> None

    (internal)

    Prevents all keyboard, mouse, and gamepad events from being processed.
    """
    return None


def log(message: str,
        to_console: bool = True,
        newline: bool = True,
        to_server: bool = True) -> None:
    """log(message: str, to_console: bool = True, newline: bool = True,
      to_server: bool = True) -> None

    Category: General Utility Functions

    Log a message. This goes to the default logging mechanism depending
    on the platform (stdout on mac, android log on android, etc).

    Log messages also go to the in-game console unless 'to_console'
    is False. They are also sent to the master-server for use in analyzing
    issues unless to_server is False.

    Python's standard print() is wired to call this (with default values)
    so in most cases you can just use that.
    """
    return None


def mac_music_app_get_library_source() -> None:
    """mac_music_app_get_library_source() -> None

    (internal)
    """
    return None


def mac_music_app_get_playlists() -> List[str]:
    """mac_music_app_get_playlists() -> List[str]

    (internal)
    """
    return ['blah', 'blah2']


def mac_music_app_get_volume() -> int:
    """mac_music_app_get_volume() -> int

    (internal)
    """
    return int()


def mac_music_app_init() -> None:
    """mac_music_app_init() -> None

    (internal)
    """
    return None


def mac_music_app_play_playlist(playlist: str) -> bool:
    """mac_music_app_play_playlist(playlist: str) -> bool

    (internal)
    """
    return bool()


def mac_music_app_set_volume(volume: int) -> None:
    """mac_music_app_set_volume(volume: int) -> None

    (internal)
    """
    return None


def mac_music_app_stop() -> None:
    """mac_music_app_stop() -> None

    (internal)
    """
    return None


def mark_config_dirty() -> None:
    """mark_config_dirty() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def mark_log_sent() -> None:
    """mark_log_sent() -> None

    (internal)
    """
    return None


def music_player_play(files: Any) -> None:
    """music_player_play(files: Any) -> None

    (internal)

    Starts internal music file playback (for internal use)
    """
    return None


def music_player_set_volume(volume: float) -> None:
    """music_player_set_volume(volume: float) -> None

    (internal)

    Sets internal music player volume (for internal use)
    """
    return None


def music_player_shutdown() -> None:
    """music_player_shutdown() -> None

    (internal)

    Finalizes internal music file playback (for internal use)
    """
    return None


def music_player_stop() -> None:
    """music_player_stop() -> None

    (internal)

    Stops internal music file playback (for internal use)
    """
    return None


def new_host_session(sessiontype: Type[ba.Session],
                     benchmark_type: str = None) -> None:
    """new_host_session(sessiontype: Type[ba.Session],
      benchmark_type: str = None) -> None

    (internal)
    """
    return None


def new_replay_session(file_name: str) -> None:
    """new_replay_session(file_name: str) -> None

    (internal)
    """
    return None


def newactivity(activity_type: Type[ba.Activity],
                settings: dict = None) -> ba.Activity:
    """newactivity(activity_type: Type[ba.Activity],
      settings: dict = None) -> ba.Activity

    Instantiates a ba.Activity given a type object.

    Category: General Utility Functions

    Activities require special setup and thus cannot be directly
    instantiated; You must go through this function.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Activity(settings={})


def newnode(type: str,
            owner: ba.Node = None,
            attrs: dict = None,
            name: str = None,
            delegate: Any = None) -> Node:
    """newnode(type: str, owner: ba.Node = None,
    attrs: dict = None, name: str = None, delegate: Any = None)
     -> Node

    Add a node of the given type to the game.

    Category: Gameplay Functions

    If a dict is provided for 'attributes', the node's initial attributes
    will be set based on them.

    'name', if provided, will be stored with the node purely for debugging
    purposes. If no name is provided, an automatic one will be generated
    such as 'terrain@foo.py:30'.

    If 'delegate' is provided, Python messages sent to the node will go to
    that object's handlemessage() method. Note that the delegate is stored
    as a weak-ref, so the node itself will not keep the object alive.

    if 'owner' is provided, the node will be automatically killed when that
    object dies. 'owner' can be another node or a ba.Actor
    """
    return Node()


def open_dir_externally(path: str) -> None:
    """open_dir_externally(path: str) -> None

    (internal)

    Open the provided dir in the default external app.
    """
    return None


def open_file_externally(path: str) -> None:
    """open_file_externally(path: str) -> None

    (internal)

    Open the provided file in the default external app.
    """
    return None


def open_url(address: str) -> None:
    """open_url(address: str) -> None

    Open a provided URL.

    Category: General Utility Functions

    Open the provided url in a web-browser, or display the URL
    string in a window if that isn't possible.
    """
    return None


def playsound(sound: Sound,
              volume: float = 1.0,
              position: Sequence[float] = None,
              host_only: bool = False) -> None:
    """playsound(sound: Sound, volume: float = 1.0,
      position: Sequence[float] = None, host_only: bool = False) -> None

    Play a ba.Sound a single time.

    Category: Gameplay Functions

    If position is not provided, the sound will be at a constant volume
    everywhere.  Position should be a float tuple of size 3.
    """
    return None


def power_ranking_query(callback: Callable, season: Any = None) -> None:
    """power_ranking_query(callback: Callable, season: Any = None) -> None

    (internal)
    """
    return None


def print_context() -> None:
    """print_context() -> None

    (internal)

    Prints info about the current context state; for debugging.
    """
    return None


def print_load_info() -> None:
    """print_load_info() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def printnodes() -> None:
    """printnodes() -> None

    Print various info about existing nodes; useful for debugging.

    Category: Gameplay Functions
    """
    return None


def printobjects() -> None:
    """printobjects() -> None

    Print debugging info about game objects.

    Category: General Utility Functions

    This call only functions in debug builds of the game.
    It prints various info about the current object count, etc.
    """
    return None


def purchase(item: str) -> None:
    """purchase(item: str) -> None

    (internal)
    """
    return None


def pushcall(call: Callable, from_other_thread: bool = False) -> None:
    """pushcall(call: Callable, from_other_thread: bool = False) -> None

    Pushes a call onto the event loop to be run during the next cycle.

    Category: General Utility Functions

    This can be handy for calls that are disallowed from within other
    callbacks, etc.

    This call expects to be used in the game thread, and will automatically
    save and restore the ba.Context to behave seamlessly.

    If you want to push a call from outside of the game thread,
    however, you can pass 'from_other_thread' as True. In this case
    the call will always run in the UI context on the game thread.
    """
    return None


def quit(soft: bool = False, back: bool = False) -> None:
    """quit(soft: bool = False, back: bool = False) -> None

    Quit the game.

    Category: General Utility Functions

    On systems like android, 'soft' will end the activity but keep the
    app running.
    """
    return None


def register_activity(activity: ba.Activity) -> ActivityData:
    """register_activity(activity: ba.Activity) -> ActivityData

    (internal)
    """
    return ActivityData()


def register_session(session: ba.Session) -> SessionData:
    """register_session(session: ba.Session) -> SessionData

    (internal)
    """
    return SessionData()


def release_gamepad_input() -> None:
    """release_gamepad_input() -> None

    (internal)

    Resumes normal gamepad event processing.
    """
    return None


def release_keyboard_input() -> None:
    """release_keyboard_input() -> None

    (internal)

    Resumes normal keyboard event processing.
    """
    return None


def reload_media() -> None:
    """reload_media() -> None

    (internal)

    Reload all currently loaded game media; useful for
    development/debugging.
    """
    return None


def report_achievement(achievement: str, pass_to_account: bool = True) -> None:
    """report_achievement(achievement: str, pass_to_account: bool = True)
      -> None

    (internal)
    """
    return None


def request_permission(permission: ba.Permission) -> None:
    """request_permission(permission: ba.Permission) -> None

    (internal)
    """
    return None


def reset_achievements() -> None:
    """reset_achievements() -> None

    (internal)
    """
    return None


def reset_game_activity_tracking() -> None:
    """reset_game_activity_tracking() -> None

    (internal)
    """
    return None


def reset_random_player_names() -> None:
    """reset_random_player_names() -> None

    (internal)
    """
    return None


def resolve_appconfig_value(key: str) -> Any:
    """resolve_appconfig_value(key: str) -> Any

    (internal)
    """
    return _uninferrable()


def restore_purchases() -> None:
    """restore_purchases() -> None

    (internal)
    """
    return None


def rowwidget(edit: Widget = None,
              parent: Widget = None,
              size: Sequence[float] = None,
              position: Sequence[float] = None,
              background: bool = None,
              selected_child: Widget = None,
              visible_child: Widget = None) -> Widget:
    """rowwidget(edit: Widget =None, parent: Widget =None,
      size: Sequence[float] = None,
      position: Sequence[float] = None,
      background: bool = None, selected_child: Widget = None,
      visible_child: Widget = None) -> Widget

    Create or edit a row widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    return Widget()


def run_transactions() -> None:
    """run_transactions() -> None

    (internal)
    """
    return None


def safecolor(color: Sequence[float],
              target_intensity: float = 0.6) -> Tuple[float, ...]:
    """safecolor(color: Sequence[float], target_intensity: float = 0.6)
      -> Tuple[float, ...]

    Given a color tuple, return a color safe to display as text.

    Category: General Utility Functions

    Accepts tuples of length 3 or 4. This will slightly brighten very
    dark colors, etc.
    """
    return (0.0, 0.0, 0.0)


def screenmessage(message: Union[str, ba.Lstr],
                  color: Sequence[float] = None,
                  top: bool = False,
                  image: Dict[str, Any] = None,
                  log: bool = False,
                  clients: Sequence[int] = None,
                  transient: bool = False) -> None:
    """screenmessage(message: Union[str, ba.Lstr],
      color: Sequence[float] = None, top: bool = False,
      image: Dict[str, Any] = None, log: bool = False,
      clients: Sequence[int] = None, transient: bool = False) -> None

    Print a message to the local client's screen, in a given color.

    Category: General Utility Functions

    If 'top' is True, the message will go to the top message area.
    For 'top' messages, 'image' can be a texture to display alongside the
    message.
    If 'log' is True, the message will also be printed to the output log
    'clients' can be a list of client-ids the message should be sent to,
    or None to specify that everyone should receive it.
    If 'transient' is True, the message will not be included in the
    game-stream and thus will not show up when viewing replays.
    Currently the 'clients' option only works for transient messages.
    """
    return None


def scrollwidget(edit: ba.Widget = None,
                 parent: ba.Widget = None,
                 size: Sequence[float] = None,
                 position: Sequence[float] = None,
                 background: bool = None,
                 selected_child: ba.Widget = None,
                 capture_arrows: bool = False,
                 on_select_call: Callable = None,
                 center_small_content: bool = None,
                 color: Sequence[float] = None,
                 highlight: bool = None,
                 border_opacity: float = None,
                 simple_culling_v: float = None) -> ba.Widget:
    """scrollwidget(edit: ba.Widget = None, parent: ba.Widget = None,
      size: Sequence[float] = None, position: Sequence[float] = None,
      background: bool = None, selected_child: ba.Widget = None,
      capture_arrows: bool = False, on_select_call: Callable = None,
      center_small_content: bool = None, color: Sequence[float] = None,
      highlight: bool = None, border_opacity: float = None,
      simple_culling_v: float = None) -> ba.Widget

    Create or edit a scroll widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    import ba  # pylint: disable=cyclic-import
    return ba.Widget()


def set_admins(admins: List[str]) -> None:
    """set_admins(admins: List[str]) -> None

    (internal)
    """
    return None


def set_analytics_screen(screen: str) -> None:
    """set_analytics_screen(screen: str) -> None

    Used for analytics to see where in the app players spend their time.

    Category: General Utility Functions

    Generally called when opening a new window or entering some UI.
    'screen' should be a string description of an app location
    ('Main Menu', etc.)
    """
    return None


def set_authenticate_clients(enable: bool) -> None:
    """set_authenticate_clients(enable: bool) -> None

    (internal)
    """
    return None


def set_debug_speed_exponent(speed: int) -> None:
    """set_debug_speed_exponent(speed: int) -> None

    (internal)

    Sets the debug speed scale for the game. Actual speed is pow(2,speed).
    """
    return None


def set_enable_default_kick_voting(enable: bool) -> None:
    """set_enable_default_kick_voting(enable: bool) -> None

    (internal)
    """
    return None


def set_have_mods(have_mods: bool) -> None:
    """set_have_mods(have_mods: bool) -> None

    (internal)
    """
    return None


def set_internal_language_keys(
        listobj: List[Tuple[str, str]],
        random_names_list: List[Tuple[str, str]]) -> None:
    """set_internal_language_keys(listobj: List[Tuple[str, str]],
      random_names_list: List[Tuple[str, str]]) -> None

    (internal)
    """
    return None


def set_low_level_config_value(key: str, value: int) -> None:
    """set_low_level_config_value(key: str, value: int) -> None

    (internal)
    """
    return None


def set_map_bounds(
        bounds: Tuple[float, float, float, float, float, float]) -> None:
    """set_map_bounds(bounds: Tuple[float, float, float, float, float, float])
      -> None

    (internal)

    Set map bounds. Generally nodes that go outside of this box are killed.
    """
    return None


def set_master_server_source(source: int) -> None:
    """set_master_server_source(source: int) -> None

    (internal)
    """
    return None


def set_party_icon_always_visible(value: bool) -> None:
    """set_party_icon_always_visible(value: bool) -> None

    (internal)
    """
    return None


def set_party_window_open(value: bool) -> None:
    """set_party_window_open(value: bool) -> None

    (internal)
    """
    return None


def set_platform_misc_read_vals(mode: str) -> None:
    """set_platform_misc_read_vals(mode: str) -> None

    (internal)
    """
    return None


def set_public_party_enabled(enabled: bool) -> None:
    """set_public_party_enabled(enabled: bool) -> None

    (internal)
    """
    return None


def set_public_party_max_size(max_size: int) -> None:
    """set_public_party_max_size(max_size: int) -> None

    (internal)
    """
    return None


def set_public_party_name(name: str) -> None:
    """set_public_party_name(name: str) -> None

    (internal)
    """
    return None


def set_public_party_stats_url(url: Optional[str]) -> None:
    """set_public_party_stats_url(url: Optional[str]) -> None

    (internal)
    """
    return None


def set_replay_speed_exponent(speed: int) -> None:
    """set_replay_speed_exponent(speed: int) -> None

    (internal)

    Set replay speed. Actual displayed speed is pow(2,speed).
    """
    return None


def set_stress_testing(testing: bool, player_count: int) -> None:
    """set_stress_testing(testing: bool, player_count: int) -> None

    (internal)
    """
    return None


def set_telnet_access_enabled(enable: bool) -> None:
    """set_telnet_access_enabled(enable: bool)
     -> None

    (internal)
    """
    return None


def set_thread_name(name: str) -> None:
    """set_thread_name(name: str) -> None

    (internal)

    Sets the name of the current thread (on platforms where this is
    available). Thread names are only for debugging and should not be
    used in logic, as naming behavior can vary across platforms.
    """
    return None


def set_touchscreen_editing(editing: bool) -> None:
    """set_touchscreen_editing(editing: bool) -> None

    (internal)
    """
    return None


def set_ui_input_device(input_device: Optional[ba.InputDevice]) -> None:
    """set_ui_input_device(input_device: Optional[ba.InputDevice]) -> None

    (internal)

    Sets the input-device that currently owns the user interface.
    """
    return None


def setup_sigint() -> None:
    """setup_sigint() -> None

    (internal)
    """
    return None


def show_ad(purpose: str,
            on_completion_call: Callable[[], None] = None) -> None:
    """show_ad(purpose: str, on_completion_call: Callable[[], None] = None)
     -> None

    (internal)
    """
    return None


def show_ad_2(purpose: str,
              on_completion_call: Callable[[bool], None] = None) -> None:
    """show_ad_2(purpose: str,
     on_completion_call: Callable[[bool], None] = None)
     -> None

    (internal)
    """
    return None


def show_app_invite(title: Union[str, ba.Lstr], message: Union[str, ba.Lstr],
                    code: str) -> None:
    """show_app_invite(title: Union[str, ba.Lstr],
      message: Union[str, ba.Lstr],
      code: str) -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def show_invites_ui() -> None:
    """show_invites_ui() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def show_online_score_ui(show: str = 'general',
                         game: str = None,
                         game_version: str = None) -> None:
    """show_online_score_ui(show: str = 'general', game: str = None,
      game_version: str = None) -> None

    (internal)
    """
    return None


def show_progress_bar() -> None:
    """show_progress_bar() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def sign_in(account_type: str) -> None:
    """sign_in(account_type: str) -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def sign_out() -> None:
    """sign_out() -> None

    (internal)

    Category: General Utility Functions
    """
    return None


def start_listening_for_wii_remotes() -> None:
    """start_listening_for_wii_remotes() -> None

    (internal)

    Start listening for connections from wii remotes.
    """
    return None


def stop_listening_for_wii_remotes() -> None:
    """stop_listening_for_wii_remotes() -> None

    (internal)

    Stop listening for connections from wii remotes.
    """
    return None


def submit_analytics_counts() -> None:
    """submit_analytics_counts() -> None

    (internal)
    """
    return None


def submit_score(game: str,
                 config: str,
                 name: Any,
                 score: Optional[int],
                 callback: Callable,
                 friend_callback: Optional[Callable],
                 order: str = 'increasing',
                 tournament_id: Optional[str] = None,
                 score_type: str = 'points',
                 campaign: Optional[str] = None,
                 level: Optional[str] = None) -> None:
    """submit_score(game: str, config: str, name: Any, score: Optional[int],
      callback: Callable, friend_callback: Optional[Callable],
      order: str = 'increasing', tournament_id: Optional[str] = None,
      score_type: str = 'points',
      campaign: Optional[str] = None,
      level: Optional[str] = None)  -> None

    (internal)

    Submit a score to the server; callback will be called with the results.
    As a courtesy, please don't send fake scores to the server. I'd prefer
    to devote my time to improving the game instead of trying to make the
    score server more mischief-proof.
    """
    return None


def textwidget(edit: Widget = None,
               parent: Widget = None,
               size: Sequence[float] = None,
               position: Sequence[float] = None,
               text: Union[str, ba.Lstr] = None,
               v_align: str = None,
               h_align: str = None,
               editable: bool = None,
               padding: float = None,
               on_return_press_call: Callable[[], None] = None,
               on_activate_call: Callable[[], None] = None,
               selectable: bool = None,
               query: Widget = None,
               max_chars: int = None,
               color: Sequence[float] = None,
               click_activate: bool = None,
               on_select_call: Callable[[], None] = None,
               always_highlight: bool = None,
               draw_controller: Widget = None,
               scale: float = None,
               corner_scale: float = None,
               description: Union[str, ba.Lstr] = None,
               transition_delay: float = None,
               maxwidth: float = None,
               max_height: float = None,
               flatness: float = None,
               shadow: float = None,
               autoselect: bool = None,
               rotate: float = None,
               enabled: bool = None,
               force_internal_editing: bool = None,
               always_show_carat: bool = None,
               big: bool = None,
               extra_touch_border_scale: float = None,
               res_scale: float = None) -> Widget:
    """textwidget(edit: Widget = None, parent: Widget = None,
      size: Sequence[float] = None, position: Sequence[float] = None,
      text: Union[str, ba.Lstr] = None, v_align: str = None,
      h_align: str = None, editable: bool = None, padding: float = None,
      on_return_press_call: Callable[[], None] = None,
      on_activate_call: Callable[[], None] = None,
      selectable: bool = None, query: Widget = None, max_chars: int = None,
      color: Sequence[float] = None, click_activate: bool = None,
      on_select_call: Callable[[], None] = None,
      always_highlight: bool = None, draw_controller: Widget = None,
      scale: float = None, corner_scale: float = None,
      description: Union[str, ba.Lstr] = None,
      transition_delay: float = None, maxwidth: float = None,
      max_height: float = None, flatness: float = None,
      shadow: float = None, autoselect: bool = None, rotate: float = None,
      enabled: bool = None, force_internal_editing: bool = None,
      always_show_carat: bool = None, big: bool = None,
      extra_touch_border_scale: float = None, res_scale: float = None)
      -> Widget

    Create or edit a text widget.

    Category: User Interface Functions

    Pass a valid existing ba.Widget as 'edit' to modify it; otherwise
    a new one is created and returned. Arguments that are not set to None
    are applied to the Widget.
    """
    return Widget()


# Overloads to return a type based on requested format.


@overload
def time(
        timetype: ba.TimeType = TimeType.SIM,
        timeformat: Literal[TimeFormat.SECONDS] = TimeFormat.SECONDS) -> float:
    ...


# This "*" keyword-only hack lets us accept 1 arg (timeformat=MILLISECS) forms.
@overload
def time(timetype: ba.TimeType = TimeType.SIM,
         *,
         timeformat: Literal[TimeFormat.MILLISECONDS]) -> int:
    ...


@overload
def time(timetype: ba.TimeType,
         timeformat: Literal[TimeFormat.MILLISECONDS]) -> int:
    ...


def time(timetype: ba.TimeType = TimeType.SIM,
         timeformat: ba.TimeFormat = TimeFormat.SECONDS) -> Any:
    """time(timetype: ba.TimeType = TimeType.SIM,
      timeformat: ba.TimeFormat = TimeFormat.SECONDS)
      -> <varies>

    Return the current time.

    Category: General Utility Functions

    The time returned depends on the current ba.Context and timetype.

    timetype can be either SIM, BASE, or REAL. It defaults to
    SIM. Types are explained below:

    SIM time maps to local simulation time in ba.Activity or ba.Session
    Contexts. This means that it may progress slower in slow-motion play
    modes, stop when the game is paused, etc.  This time type is not
    available in UI contexts.

    BASE time is also linked to gameplay in ba.Activity or ba.Session
    Contexts, but it progresses at a constant rate regardless of
     slow-motion states or pausing.  It can, however, slow down or stop
    in certain cases such as network outages or game slowdowns due to
    cpu load. Like 'sim' time, this is unavailable in UI contexts.

    REAL time always maps to actual clock time with a bit of filtering
    added, regardless of Context.  (the filtering prevents it from going
    backwards or jumping forward by large amounts due to the app being
    backgrounded, system time changing, etc.)

    the 'timeformat' arg defaults to SECONDS which returns float seconds,
    but it can also be MILLISECONDS to return integer milliseconds.

    Note: If you need pure unfiltered clock time, just use the standard
    Python functions such as time.time().
    """
    return None


def time_format_check(time_format: ba.TimeFormat, length: Union[float,
                                                                int]) -> None:
    """time_format_check(time_format: ba.TimeFormat, length: Union[float, int])
      -> None

    (internal)

    Logs suspicious time values for timers or animate calls.

    (for helping with the transition from milliseconds-based time calls
    to seconds-based ones)
    """
    return None


def timer(time: float,
          call: Callable[[], Any],
          repeat: bool = False,
          timetype: ba.TimeType = TimeType.SIM,
          timeformat: ba.TimeFormat = TimeFormat.SECONDS,
          suppress_format_warning: bool = False) -> None:
    """timer(time: float, call: Callable[[], Any], repeat: bool = False,
      timetype: ba.TimeType = TimeType.SIM,
      timeformat: ba.TimeFormat = TimeFormat.SECONDS,
      suppress_format_warning: bool = False)
     -> None

    Schedule a call to run at a later point in time.

    Category: General Utility Functions

    This function adds a timer to the current ba.Context.
    This timer cannot be canceled or modified once created. If you
     require the ability to do so, use the ba.Timer class instead.

    time: length of time (in seconds by default) that the timer will wait
    before firing. Note that the actual delay experienced may vary
     depending on the timetype. (see below)

    call: A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as ba.WeakCall if that is not
    desired.

    repeat: if True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    timetype can be either 'sim', 'base', or 'real'. It defaults to
    'sim'. Types are explained below:

    'sim' time maps to local simulation time in ba.Activity or ba.Session
    Contexts. This means that it may progress slower in slow-motion play
    modes, stop when the game is paused, etc.  This time type is not
    available in UI contexts.

    'base' time is also linked to gameplay in ba.Activity or ba.Session
    Contexts, but it progresses at a constant rate regardless of
     slow-motion states or pausing.  It can, however, slow down or stop
    in certain cases such as network outages or game slowdowns due to
    cpu load. Like 'sim' time, this is unavailable in UI contexts.

    'real' time always maps to actual clock time with a bit of filtering
    added, regardless of Context.  (the filtering prevents it from going
    backwards or jumping forward by large amounts due to the app being
    backgrounded, system time changing, etc.)
    Real time timers are currently only available in the UI context.

    the 'timeformat' arg defaults to seconds but can also be milliseconds.

    # timer example: print some stuff through time:
    ba.screenmessage('hello from now!')
    ba.timer(1.0, ba.Call(ba.screenmessage, 'hello from the future!'))
    ba.timer(2.0, ba.Call(ba.screenmessage, 'hello from the future 2!'))
    """
    return None


def tournament_query(callback: Callable[[Optional[Dict]], None],
                     args: Dict) -> None:
    """tournament_query(callback: Callable[[Optional[Dict]], None],
      args: Dict) -> None

    (internal)
    """
    return None


def uibounds() -> Tuple[float, float, float, float]:
    """uibounds() -> Tuple[float, float, float, float]

    (internal)

    Returns a tuple of 4 values: (x-min, x-max, y-min, y-max) representing
    the range of values that can be plugged into a root level
    ba.ContainerWidget's stack_offset value while guaranteeing that its
    center remains onscreen.
    """
    return (0.0, 0.0, 0.0, 0.0)


def unlock_all_input() -> None:
    """unlock_all_input() -> None

    (internal)

    Resumes normal keyboard, mouse, and gamepad event processing.
    """
    return None


def value_test(arg: str,
               change: float = None,
               absolute: float = None) -> float:
    """value_test(arg: str, change: float = None, absolute: float = None)
      -> float

    (internal)
    """
    return float()


def widget(edit: ba.Widget = None,
           up_widget: ba.Widget = None,
           down_widget: ba.Widget = None,
           left_widget: ba.Widget = None,
           right_widget: ba.Widget = None,
           show_buffer_top: float = None,
           show_buffer_bottom: float = None,
           show_buffer_left: float = None,
           show_buffer_right: float = None,
           autoselect: bool = None) -> None:
    """widget(edit: ba.Widget = None, up_widget: ba.Widget = None,
      down_widget: ba.Widget = None, left_widget: ba.Widget = None,
      right_widget: ba.Widget = None, show_buffer_top: float = None,
      show_buffer_bottom: float = None, show_buffer_left: float = None,
      show_buffer_right: float = None, autoselect: bool = None) -> None

    Edit common attributes of any widget.

    Category: User Interface Functions

    Unlike other UI calls, this can only be used to edit, not to create.
    """
    return None
